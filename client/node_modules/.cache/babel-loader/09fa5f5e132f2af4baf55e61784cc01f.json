{"ast":null,"code":"\"use strict\";\n\nlet interlaceUtils = require(\"./interlace\");\n\nlet paethPredictor = require(\"./paeth-predictor\");\n\nfunction getByteWidth(width, bpp, depth) {\n  let byteWidth = width * bpp;\n\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n\n  return byteWidth;\n}\n\nlet Filter = module.exports = function (bitmapInfo, dependencies) {\n  let width = bitmapInfo.width;\n  let height = bitmapInfo.height;\n  let interlace = bitmapInfo.interlace;\n  let bpp = bitmapInfo.bpp;\n  let depth = bitmapInfo.depth;\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n  this._imageIndex = 0;\n  this._images = [];\n\n  if (interlace) {\n    let passes = interlaceUtils.getImagePasses(width, height);\n\n    for (let i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0\n      });\n    }\n  } else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0\n    });\n  } // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n\n\n  if (depth === 8) {\n    this._xComparison = bpp;\n  } else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  } else {\n    this._xComparison = 1;\n  }\n};\n\nFilter.prototype.start = function () {\n  this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));\n};\n\nFilter.prototype._unFilterType1 = function (rawData, unfilteredLine, byteWidth) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function (rawData, unfilteredLine, byteWidth) {\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function (rawData, unfilteredLine, byteWidth) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f3Up = lastLine ? lastLine[x] : 0;\n    let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    let f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function (rawData, unfilteredLine, byteWidth) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f4Up = lastLine ? lastLine[x] : 0;\n    let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function (rawData) {\n  let filter = rawData[0];\n  let unfilteredLine;\n  let currentImage = this._images[this._imageIndex];\n  let byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  } else {\n    unfilteredLine = Buffer.alloc(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n\n        break;\n\n      default:\n        throw new Error(\"Unrecognised filter type - \" + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n  currentImage.lineIndex++;\n\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  } else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  } else {\n    this._lastLine = null;\n    this.complete();\n  }\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/pngjs/lib/filter-parse.js"],"names":["interlaceUtils","require","paethPredictor","getByteWidth","width","bpp","depth","byteWidth","Math","ceil","Filter","module","exports","bitmapInfo","dependencies","height","interlace","read","write","complete","_imageIndex","_images","passes","getImagePasses","i","length","push","lineIndex","_xComparison","prototype","start","_reverseFilterLine","bind","_unFilterType1","rawData","unfilteredLine","xComparison","xBiggerThan","x","rawByte","f1Left","_unFilterType2","lastLine","_lastLine","f2Up","_unFilterType3","f3Up","f3Left","f3Add","floor","_unFilterType4","f4Up","f4Left","f4UpLeft","f4Add","filter","currentImage","slice","Buffer","alloc","Error"],"mappings":"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","sourcesContent":["\"use strict\";\n\nlet interlaceUtils = require(\"./interlace\");\nlet paethPredictor = require(\"./paeth-predictor\");\n\nfunction getByteWidth(width, bpp, depth) {\n  let byteWidth = width * bpp;\n  if (depth !== 8) {\n    byteWidth = Math.ceil(byteWidth / (8 / depth));\n  }\n  return byteWidth;\n}\n\nlet Filter = (module.exports = function (bitmapInfo, dependencies) {\n  let width = bitmapInfo.width;\n  let height = bitmapInfo.height;\n  let interlace = bitmapInfo.interlace;\n  let bpp = bitmapInfo.bpp;\n  let depth = bitmapInfo.depth;\n\n  this.read = dependencies.read;\n  this.write = dependencies.write;\n  this.complete = dependencies.complete;\n\n  this._imageIndex = 0;\n  this._images = [];\n  if (interlace) {\n    let passes = interlaceUtils.getImagePasses(width, height);\n    for (let i = 0; i < passes.length; i++) {\n      this._images.push({\n        byteWidth: getByteWidth(passes[i].width, bpp, depth),\n        height: passes[i].height,\n        lineIndex: 0,\n      });\n    }\n  } else {\n    this._images.push({\n      byteWidth: getByteWidth(width, bpp, depth),\n      height: height,\n      lineIndex: 0,\n    });\n  }\n\n  // when filtering the line we look at the pixel to the left\n  // the spec also says it is done on a byte level regardless of the number of pixels\n  // so if the depth is byte compatible (8 or 16) we subtract the bpp in order to compare back\n  // a pixel rather than just a different byte part. However if we are sub byte, we ignore.\n  if (depth === 8) {\n    this._xComparison = bpp;\n  } else if (depth === 16) {\n    this._xComparison = bpp * 2;\n  } else {\n    this._xComparison = 1;\n  }\n});\n\nFilter.prototype.start = function () {\n  this.read(\n    this._images[this._imageIndex].byteWidth + 1,\n    this._reverseFilterLine.bind(this)\n  );\n};\n\nFilter.prototype._unFilterType1 = function (\n  rawData,\n  unfilteredLine,\n  byteWidth\n) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    unfilteredLine[x] = rawByte + f1Left;\n  }\n};\n\nFilter.prototype._unFilterType2 = function (\n  rawData,\n  unfilteredLine,\n  byteWidth\n) {\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f2Up = lastLine ? lastLine[x] : 0;\n    unfilteredLine[x] = rawByte + f2Up;\n  }\n};\n\nFilter.prototype._unFilterType3 = function (\n  rawData,\n  unfilteredLine,\n  byteWidth\n) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f3Up = lastLine ? lastLine[x] : 0;\n    let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    let f3Add = Math.floor((f3Left + f3Up) / 2);\n    unfilteredLine[x] = rawByte + f3Add;\n  }\n};\n\nFilter.prototype._unFilterType4 = function (\n  rawData,\n  unfilteredLine,\n  byteWidth\n) {\n  let xComparison = this._xComparison;\n  let xBiggerThan = xComparison - 1;\n  let lastLine = this._lastLine;\n\n  for (let x = 0; x < byteWidth; x++) {\n    let rawByte = rawData[1 + x];\n    let f4Up = lastLine ? lastLine[x] : 0;\n    let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;\n    let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;\n    let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);\n    unfilteredLine[x] = rawByte + f4Add;\n  }\n};\n\nFilter.prototype._reverseFilterLine = function (rawData) {\n  let filter = rawData[0];\n  let unfilteredLine;\n  let currentImage = this._images[this._imageIndex];\n  let byteWidth = currentImage.byteWidth;\n\n  if (filter === 0) {\n    unfilteredLine = rawData.slice(1, byteWidth + 1);\n  } else {\n    unfilteredLine = Buffer.alloc(byteWidth);\n\n    switch (filter) {\n      case 1:\n        this._unFilterType1(rawData, unfilteredLine, byteWidth);\n        break;\n      case 2:\n        this._unFilterType2(rawData, unfilteredLine, byteWidth);\n        break;\n      case 3:\n        this._unFilterType3(rawData, unfilteredLine, byteWidth);\n        break;\n      case 4:\n        this._unFilterType4(rawData, unfilteredLine, byteWidth);\n        break;\n      default:\n        throw new Error(\"Unrecognised filter type - \" + filter);\n    }\n  }\n\n  this.write(unfilteredLine);\n\n  currentImage.lineIndex++;\n  if (currentImage.lineIndex >= currentImage.height) {\n    this._lastLine = null;\n    this._imageIndex++;\n    currentImage = this._images[this._imageIndex];\n  } else {\n    this._lastLine = unfilteredLine;\n  }\n\n  if (currentImage) {\n    // read, using the byte width that may be from the new current image\n    this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));\n  } else {\n    this._lastLine = null;\n    this.complete();\n  }\n};\n"]},"metadata":{},"sourceType":"script"}