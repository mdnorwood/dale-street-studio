{"ast":null,"code":"(function (exports) {\n  'use strict';\n\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n  function b64ToByteArray(b64) {\n    var i, j, l, tmp, placeHolders, arr;\n\n    if (b64.length % 4 > 0) {\n      throw 'Invalid string. Length must be a multiple of 4';\n    } // the number of equal signs (place holders)\n    // if there are two placeholders, than the two characters before it\n    // represent one byte\n    // if there is only one, then the three characters before it represent 2 bytes\n    // this is just a cheap hack to not do indexOf twice\n\n\n    placeHolders = b64.indexOf('=');\n    placeHolders = placeHolders > 0 ? b64.length - placeHolders : 0; // base64 is 4/3 + up to two characters of the original data\n\n    arr = []; //new Uint8Array(b64.length * 3 / 4 - placeHolders);\n    // if there are placeholders, only get up to the last complete 4 chars\n\n    l = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n    for (i = 0, j = 0; i < l; i += 4, j += 3) {\n      tmp = lookup.indexOf(b64[i]) << 18 | lookup.indexOf(b64[i + 1]) << 12 | lookup.indexOf(b64[i + 2]) << 6 | lookup.indexOf(b64[i + 3]);\n      arr.push((tmp & 0xFF0000) >> 16);\n      arr.push((tmp & 0xFF00) >> 8);\n      arr.push(tmp & 0xFF);\n    }\n\n    if (placeHolders === 2) {\n      tmp = lookup.indexOf(b64[i]) << 2 | lookup.indexOf(b64[i + 1]) >> 4;\n      arr.push(tmp & 0xFF);\n    } else if (placeHolders === 1) {\n      tmp = lookup.indexOf(b64[i]) << 10 | lookup.indexOf(b64[i + 1]) << 4 | lookup.indexOf(b64[i + 2]) >> 2;\n      arr.push(tmp >> 8 & 0xFF);\n      arr.push(tmp & 0xFF);\n    }\n\n    return arr;\n  }\n\n  function uint8ToBase64(uint8) {\n    var i,\n        extraBytes = uint8.length % 3,\n        // if we have 1 byte left, pad 2 bytes\n    output = \"\",\n        temp,\n        length;\n\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n    }\n\n    ; // go through the array every three bytes, we'll deal with trailing stuff later\n\n    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n      output += tripletToBase64(temp);\n    } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n    switch (extraBytes) {\n      case 1:\n        temp = uint8[uint8.length - 1];\n        output += lookup[temp >> 2];\n        output += lookup[temp << 4 & 0x3F];\n        output += '==';\n        break;\n\n      case 2:\n        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n        output += lookup[temp >> 10];\n        output += lookup[temp >> 4 & 0x3F];\n        output += lookup[temp << 2 & 0x3F];\n        output += '=';\n        break;\n    }\n\n    return output;\n  }\n\n  module.exports.toByteArray = b64ToByteArray;\n  module.exports.fromByteArray = uint8ToBase64;\n})();","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/bops/node_modules/base64-js/lib/b64.js"],"names":["exports","lookup","b64ToByteArray","b64","i","j","l","tmp","placeHolders","arr","length","indexOf","push","uint8ToBase64","uint8","extraBytes","output","temp","tripletToBase64","num","module","toByteArray","fromByteArray"],"mappings":"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","sourcesContent":["(function (exports) {\n\t'use strict';\n\n\tvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n\tfunction b64ToByteArray(b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr;\n\t\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow 'Invalid string. Length must be a multiple of 4';\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tplaceHolders = b64.indexOf('=');\n\t\tplaceHolders = placeHolders > 0 ? b64.length - placeHolders : 0;\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = [];//new Uint8Array(b64.length * 3 / 4 - placeHolders);\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length;\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 18) | (lookup.indexOf(b64[i + 1]) << 12) | (lookup.indexOf(b64[i + 2]) << 6) | lookup.indexOf(b64[i + 3]);\n\t\t\tarr.push((tmp & 0xFF0000) >> 16);\n\t\t\tarr.push((tmp & 0xFF00) >> 8);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 2) | (lookup.indexOf(b64[i + 1]) >> 4);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (lookup.indexOf(b64[i]) << 10) | (lookup.indexOf(b64[i + 1]) << 4) | (lookup.indexOf(b64[i + 2]) >> 2);\n\t\t\tarr.push((tmp >> 8) & 0xFF);\n\t\t\tarr.push(tmp & 0xFF);\n\t\t}\n\n\t\treturn arr;\n\t}\n\n\tfunction uint8ToBase64(uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length;\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n\t\t};\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n\t\t\toutput += tripletToBase64(temp);\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1];\n\t\t\t\toutput += lookup[temp >> 2];\n\t\t\t\toutput += lookup[(temp << 4) & 0x3F];\n\t\t\t\toutput += '==';\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n\t\t\t\toutput += lookup[temp >> 10];\n\t\t\t\toutput += lookup[(temp >> 4) & 0x3F];\n\t\t\t\toutput += lookup[(temp << 2) & 0x3F];\n\t\t\t\toutput += '=';\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn output;\n\t}\n\n\tmodule.exports.toByteArray = b64ToByteArray;\n\tmodule.exports.fromByteArray = uint8ToBase64;\n}());\n"]},"metadata":{},"sourceType":"script"}