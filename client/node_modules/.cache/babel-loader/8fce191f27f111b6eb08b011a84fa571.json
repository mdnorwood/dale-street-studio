{"ast":null,"code":"'use strict'; // NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n// TO-DO: handle all JFIFs\n\nvar validJFIFMarkers = {\n  'ffdb': '0001010101',\n  // Samsung D807 JPEG\n  'ffe0': '4a46494600',\n  // Standard JPEG\n  'ffe1': '4578696600',\n  // Camera JPEG, with EXIF data\n  'ffe2': '4943435f50',\n  // Canon EOS-1D JPEG\n  'ffe3': '',\n  // Samsung D500 JPEG\n  'ffe8': '5350494646',\n  // SPIFF JPEG\n  'ffec': '4475636b79',\n  // Photoshop JPEG\n  'ffed': '50686f746f',\n  // Adobe JPEG, Photoshop CMYK buffer\n  'ffee': '41646f6265' // Adobe JPEG, Unrecognised (Lightroom??)\n\n};\nvar red = ['\\x1B[31m', '\\x1B[39m'];\n\nfunction isJPG(buffer) {\n  //, filepath\n  var SOIMarker = buffer.toString('hex', 0, 2);\n  var JFIFMarker = buffer.toString('hex', 2, 4); // not a valid jpeg\n\n  if ('ffd8' !== SOIMarker) {\n    return false;\n  } // TO-DO: validate the end-bytes of a jpeg file\n  // use filepath, get the last bytes, check for ffd9\n\n\n  var got = buffer.toString('hex', 6, 11);\n  var expected = JFIFMarker && validJFIFMarkers[JFIFMarker];\n\n  if (expected === '') {\n    console.warn(red[0] + 'this looks like a unrecognised jpeg\\n' + 'please report the issue here\\n' + red[1], '\\thttps://github.com/netroy/image-size/issues/new\\n');\n    return false;\n  }\n\n  return got === expected || JFIFMarker === 'ffdb';\n}\n\nfunction extractSize(buffer, i) {\n  return {\n    'height': buffer.readUInt16BE(i),\n    'width': buffer.readUInt16BE(i + 2)\n  };\n}\n\nfunction validateBuffer(buffer, i) {\n  // index should be within buffer limits\n  if (i > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  } // Every JPEG block must begin with a 0xFF\n\n\n  if (buffer[i] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nfunction calculate(buffer) {\n  // Skip 5 chars, they are for signature\n  buffer = buffer.slice(4);\n  var i, next;\n\n  while (buffer.length) {\n    // read length of the next block\n    i = buffer.readUInt16BE(0); // ensure correct format\n\n    validateBuffer(buffer, i); // 0xFFC0 is baseline(SOF)\n    // 0xFFC2 is progressive(SOF2)\n\n    next = buffer[i + 1];\n\n    if (next === 0xC0 || next === 0xC2) {\n      return extractSize(buffer, i + 5);\n    } // move to the next block\n\n\n    buffer = buffer.slice(i + 2);\n  }\n\n  throw new TypeError('Invalid JPG, no size found');\n}\n\nmodule.exports = {\n  'detect': isJPG,\n  'calculate': calculate\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/image-size/lib/types/jpg.js"],"names":["validJFIFMarkers","red","isJPG","buffer","SOIMarker","toString","JFIFMarker","got","expected","console","warn","extractSize","i","readUInt16BE","validateBuffer","length","TypeError","calculate","slice","next","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n\n// TO-DO: handle all JFIFs\nvar validJFIFMarkers = {\n  'ffdb': '0001010101', // Samsung D807 JPEG\n  'ffe0': '4a46494600', // Standard JPEG\n  'ffe1': '4578696600', // Camera JPEG, with EXIF data\n  'ffe2': '4943435f50', // Canon EOS-1D JPEG\n  'ffe3': '',           // Samsung D500 JPEG\n  'ffe8': '5350494646', // SPIFF JPEG\n  'ffec': '4475636b79', // Photoshop JPEG\n  'ffed': '50686f746f', // Adobe JPEG, Photoshop CMYK buffer\n  'ffee': '41646f6265'  // Adobe JPEG, Unrecognised (Lightroom??)\n};\n\nvar red = ['\\x1B[31m', '\\x1B[39m'];\nfunction isJPG (buffer) { //, filepath\n  var SOIMarker = buffer.toString('hex', 0, 2);\n  var JFIFMarker = buffer.toString('hex', 2, 4);\n\n  // not a valid jpeg\n  if ('ffd8' !== SOIMarker) {\n    return false;\n  }\n\n  // TO-DO: validate the end-bytes of a jpeg file\n  // use filepath, get the last bytes, check for ffd9\n  var got = buffer.toString('hex', 6, 11);\n  var expected = JFIFMarker && validJFIFMarkers[JFIFMarker];\n  if (expected === '') {\n    console.warn(\n      red[0] +\n      'this looks like a unrecognised jpeg\\n' +\n      'please report the issue here\\n' +\n      red[1],\n      '\\thttps://github.com/netroy/image-size/issues/new\\n'\n    );\n    return false;\n  }\n  return (got === expected) || (JFIFMarker === 'ffdb');\n}\n\nfunction extractSize (buffer, i) {\n  return {\n    'height' : buffer.readUInt16BE(i),\n    'width' : buffer.readUInt16BE(i + 2)\n  };\n}\n\nfunction validateBuffer (buffer, i) {\n  // index should be within buffer limits\n  if (i > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  }\n  // Every JPEG block must begin with a 0xFF\n  if (buffer[i] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nfunction calculate (buffer) {\n\n  // Skip 5 chars, they are for signature\n  buffer = buffer.slice(4);\n\n  var i, next;\n  while (buffer.length) {\n    // read length of the next block\n    i = buffer.readUInt16BE(0);\n\n    // ensure correct format\n    validateBuffer(buffer, i);\n\n    // 0xFFC0 is baseline(SOF)\n    // 0xFFC2 is progressive(SOF2)\n    next = buffer[i + 1];\n    if (next === 0xC0 || next === 0xC2) {\n      return extractSize(buffer, i + 5);\n    }\n\n    // move to the next block\n    buffer = buffer.slice(i + 2);\n  }\n\n  throw new TypeError('Invalid JPG, no size found');\n}\n\nmodule.exports = {\n  'detect': isJPG,\n  'calculate': calculate\n};\n"]},"metadata":{},"sourceType":"script"}