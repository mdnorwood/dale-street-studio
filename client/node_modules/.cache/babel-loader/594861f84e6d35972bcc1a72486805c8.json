{"ast":null,"code":"/*!\n * @overview RSVP - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n * @version   3.0.21\n */\n(function () {\n  \"use strict\";\n\n  function lib$rsvp$utils$$objectOrFunction(x) {\n    return typeof x === 'function' || typeof x === 'object' && x !== null;\n  }\n\n  function lib$rsvp$utils$$isFunction(x) {\n    return typeof x === 'function';\n  }\n\n  function lib$rsvp$utils$$isMaybeThenable(x) {\n    return typeof x === 'object' && x !== null;\n  }\n\n  var lib$rsvp$utils$$_isArray;\n\n  if (!Array.isArray) {\n    lib$rsvp$utils$$_isArray = function lib$rsvp$utils$$_isArray(x) {\n      return Object.prototype.toString.call(x) === '[object Array]';\n    };\n  } else {\n    lib$rsvp$utils$$_isArray = Array.isArray;\n  }\n\n  var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;\n\n  var lib$rsvp$utils$$now = Date.now || function () {\n    return new Date().getTime();\n  };\n\n  function lib$rsvp$utils$$F() {}\n\n  var lib$rsvp$utils$$o_create = Object.create || function (o) {\n    if (arguments.length > 1) {\n      throw new Error('Second argument not supported');\n    }\n\n    if (typeof o !== 'object') {\n      throw new TypeError('Argument must be an object');\n    }\n\n    lib$rsvp$utils$$F.prototype = o;\n    return new lib$rsvp$utils$$F();\n  };\n\n  function lib$rsvp$events$$indexOf(callbacks, callback) {\n    for (var i = 0, l = callbacks.length; i < l; i++) {\n      if (callbacks[i] === callback) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  function lib$rsvp$events$$callbacksFor(object) {\n    var callbacks = object._promiseCallbacks;\n\n    if (!callbacks) {\n      callbacks = object._promiseCallbacks = {};\n    }\n\n    return callbacks;\n  }\n\n  var lib$rsvp$events$$default = {\n    /**\n      `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For\n      Example:\n       ```javascript\n      var object = {};\n       RSVP.EventTarget.mixin(object);\n       object.on('finished', function(event) {\n        // handle event\n      });\n       object.trigger('finished', { detail: value });\n      ```\n       `EventTarget.mixin` also works with prototypes:\n       ```javascript\n      var Person = function() {};\n      RSVP.EventTarget.mixin(Person.prototype);\n       var yehuda = new Person();\n      var tom = new Person();\n       yehuda.on('poke', function(event) {\n        console.log('Yehuda says OW');\n      });\n       tom.on('poke', function(event) {\n        console.log('Tom says OW');\n      });\n       yehuda.trigger('poke');\n      tom.trigger('poke');\n      ```\n       @method mixin\n      @for RSVP.EventTarget\n      @private\n      @param {Object} object object to extend with EventTarget methods\n    */\n    'mixin': function mixin(object) {\n      object['on'] = this['on'];\n      object['off'] = this['off'];\n      object['trigger'] = this['trigger'];\n      object._promiseCallbacks = undefined;\n      return object;\n    },\n\n    /**\n      Registers a callback to be executed when `eventName` is triggered\n       ```javascript\n      object.on('event', function(eventInfo){\n        // handle the event\n      });\n       object.trigger('event');\n      ```\n       @method on\n      @for RSVP.EventTarget\n      @private\n      @param {String} eventName name of the event to listen for\n      @param {Function} callback function to be called when the event is triggered.\n    */\n    'on': function on(eventName, callback) {\n      if (typeof callback !== 'function') {\n        throw new TypeError('Callback must be a function');\n      }\n\n      var allCallbacks = lib$rsvp$events$$callbacksFor(this),\n          callbacks;\n      callbacks = allCallbacks[eventName];\n\n      if (!callbacks) {\n        callbacks = allCallbacks[eventName] = [];\n      }\n\n      if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {\n        callbacks.push(callback);\n      }\n    },\n\n    /**\n      You can use `off` to stop firing a particular callback for an event:\n       ```javascript\n      function doStuff() { // do stuff! }\n      object.on('stuff', doStuff);\n       object.trigger('stuff'); // doStuff will be called\n       // Unregister ONLY the doStuff callback\n      object.off('stuff', doStuff);\n      object.trigger('stuff'); // doStuff will NOT be called\n      ```\n       If you don't pass a `callback` argument to `off`, ALL callbacks for the\n      event will not be executed when the event fires. For example:\n       ```javascript\n      var callback1 = function(){};\n      var callback2 = function(){};\n       object.on('stuff', callback1);\n      object.on('stuff', callback2);\n       object.trigger('stuff'); // callback1 and callback2 will be executed.\n       object.off('stuff');\n      object.trigger('stuff'); // callback1 and callback2 will not be executed!\n      ```\n       @method off\n      @for RSVP.EventTarget\n      @private\n      @param {String} eventName event to stop listening to\n      @param {Function} callback optional argument. If given, only the function\n      given will be removed from the event's callback queue. If no `callback`\n      argument is given, all callbacks will be removed from the event's callback\n      queue.\n    */\n    'off': function off(eventName, callback) {\n      var allCallbacks = lib$rsvp$events$$callbacksFor(this),\n          callbacks,\n          index;\n\n      if (!callback) {\n        allCallbacks[eventName] = [];\n        return;\n      }\n\n      callbacks = allCallbacks[eventName];\n      index = lib$rsvp$events$$indexOf(callbacks, callback);\n\n      if (index !== -1) {\n        callbacks.splice(index, 1);\n      }\n    },\n\n    /**\n      Use `trigger` to fire custom events. For example:\n       ```javascript\n      object.on('foo', function(){\n        console.log('foo event happened!');\n      });\n      object.trigger('foo');\n      // 'foo event happened!' logged to the console\n      ```\n       You can also pass a value as a second argument to `trigger` that will be\n      passed as an argument to all event listeners for the event:\n       ```javascript\n      object.on('foo', function(value){\n        console.log(value.name);\n      });\n       object.trigger('foo', { name: 'bar' });\n      // 'bar' logged to the console\n      ```\n       @method trigger\n      @for RSVP.EventTarget\n      @private\n      @param {String} eventName name of the event to be triggered\n      @param {*} options optional value to be passed to any event handlers for\n      the given `eventName`\n    */\n    'trigger': function trigger(eventName, options) {\n      var allCallbacks = lib$rsvp$events$$callbacksFor(this),\n          callbacks,\n          callback;\n\n      if (callbacks = allCallbacks[eventName]) {\n        // Don't cache the callbacks.length since it may grow\n        for (var i = 0; i < callbacks.length; i++) {\n          callback = callbacks[i];\n          callback(options);\n        }\n      }\n    }\n  };\n  var lib$rsvp$config$$config = {\n    instrument: false\n  };\n  lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);\n\n  function lib$rsvp$config$$configure(name, value) {\n    if (name === 'onerror') {\n      // handle for legacy users that expect the actual\n      // error to be passed to their function added via\n      // `RSVP.configure('onerror', someFunctionHere);`\n      lib$rsvp$config$$config['on']('error', value);\n      return;\n    }\n\n    if (arguments.length === 2) {\n      lib$rsvp$config$$config[name] = value;\n    } else {\n      return lib$rsvp$config$$config[name];\n    }\n  }\n\n  var lib$rsvp$instrument$$queue = [];\n\n  function lib$rsvp$instrument$$scheduleFlush() {\n    setTimeout(function () {\n      var entry;\n\n      for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {\n        entry = lib$rsvp$instrument$$queue[i];\n        var payload = entry.payload;\n        payload.guid = payload.key + payload.id;\n        payload.childGuid = payload.key + payload.childId;\n\n        if (payload.error) {\n          payload.stack = payload.error.stack;\n        }\n\n        lib$rsvp$config$$config['trigger'](entry.name, entry.payload);\n      }\n\n      lib$rsvp$instrument$$queue.length = 0;\n    }, 50);\n  }\n\n  function lib$rsvp$instrument$$instrument(eventName, promise, child) {\n    if (1 === lib$rsvp$instrument$$queue.push({\n      name: eventName,\n      payload: {\n        key: promise._guidKey,\n        id: promise._id,\n        eventName: eventName,\n        detail: promise._result,\n        childId: child && child._id,\n        label: promise._label,\n        timeStamp: lib$rsvp$utils$$now(),\n        error: lib$rsvp$config$$config[\"instrument-with-stack\"] ? new Error(promise._label) : null\n      }\n    })) {\n      lib$rsvp$instrument$$scheduleFlush();\n    }\n  }\n\n  var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;\n\n  function lib$rsvp$$internal$$withOwnPromise() {\n    return new TypeError('A promises callback cannot return that same promise.');\n  }\n\n  function lib$rsvp$$internal$$noop() {}\n\n  var lib$rsvp$$internal$$PENDING = void 0;\n  var lib$rsvp$$internal$$FULFILLED = 1;\n  var lib$rsvp$$internal$$REJECTED = 2;\n  var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n  function lib$rsvp$$internal$$getThen(promise) {\n    try {\n      return promise.then;\n    } catch (error) {\n      lib$rsvp$$internal$$GET_THEN_ERROR.error = error;\n      return lib$rsvp$$internal$$GET_THEN_ERROR;\n    }\n  }\n\n  function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n    try {\n      then.call(value, fulfillmentHandler, rejectionHandler);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {\n    lib$rsvp$config$$config.async(function (promise) {\n      var sealed = false;\n      var error = lib$rsvp$$internal$$tryThen(then, thenable, function (value) {\n        if (sealed) {\n          return;\n        }\n\n        sealed = true;\n\n        if (thenable !== value) {\n          lib$rsvp$$internal$$resolve(promise, value);\n        } else {\n          lib$rsvp$$internal$$fulfill(promise, value);\n        }\n      }, function (reason) {\n        if (sealed) {\n          return;\n        }\n\n        sealed = true;\n        lib$rsvp$$internal$$reject(promise, reason);\n      }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n      if (!sealed && error) {\n        sealed = true;\n        lib$rsvp$$internal$$reject(promise, error);\n      }\n    }, promise);\n  }\n\n  function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {\n    if (thenable._state === lib$rsvp$$internal$$FULFILLED) {\n      lib$rsvp$$internal$$fulfill(promise, thenable._result);\n    } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {\n      thenable._onError = null;\n      lib$rsvp$$internal$$reject(promise, thenable._result);\n    } else {\n      lib$rsvp$$internal$$subscribe(thenable, undefined, function (value) {\n        if (thenable !== value) {\n          lib$rsvp$$internal$$resolve(promise, value);\n        } else {\n          lib$rsvp$$internal$$fulfill(promise, value);\n        }\n      }, function (reason) {\n        lib$rsvp$$internal$$reject(promise, reason);\n      });\n    }\n  }\n\n  function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {\n    if (maybeThenable.constructor === promise.constructor) {\n      lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);\n    } else {\n      var then = lib$rsvp$$internal$$getThen(maybeThenable);\n\n      if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {\n        lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);\n      } else if (then === undefined) {\n        lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n      } else if (lib$rsvp$utils$$isFunction(then)) {\n        lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);\n      } else {\n        lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n      }\n    }\n  }\n\n  function lib$rsvp$$internal$$resolve(promise, value) {\n    if (promise === value) {\n      lib$rsvp$$internal$$fulfill(promise, value);\n    } else if (lib$rsvp$utils$$objectOrFunction(value)) {\n      lib$rsvp$$internal$$handleMaybeThenable(promise, value);\n    } else {\n      lib$rsvp$$internal$$fulfill(promise, value);\n    }\n  }\n\n  function lib$rsvp$$internal$$publishRejection(promise) {\n    if (promise._onError) {\n      promise._onError(promise._result);\n    }\n\n    lib$rsvp$$internal$$publish(promise);\n  }\n\n  function lib$rsvp$$internal$$fulfill(promise, value) {\n    if (promise._state !== lib$rsvp$$internal$$PENDING) {\n      return;\n    }\n\n    promise._result = value;\n    promise._state = lib$rsvp$$internal$$FULFILLED;\n\n    if (promise._subscribers.length === 0) {\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default('fulfilled', promise);\n      }\n    } else {\n      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);\n    }\n  }\n\n  function lib$rsvp$$internal$$reject(promise, reason) {\n    if (promise._state !== lib$rsvp$$internal$$PENDING) {\n      return;\n    }\n\n    promise._state = lib$rsvp$$internal$$REJECTED;\n    promise._result = reason;\n    lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);\n  }\n\n  function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n    var subscribers = parent._subscribers;\n    var length = subscribers.length;\n    parent._onError = null;\n    subscribers[length] = child;\n    subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;\n    subscribers[length + lib$rsvp$$internal$$REJECTED] = onRejection;\n\n    if (length === 0 && parent._state) {\n      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);\n    }\n  }\n\n  function lib$rsvp$$internal$$publish(promise) {\n    var subscribers = promise._subscribers;\n    var settled = promise._state;\n\n    if (lib$rsvp$config$$config.instrument) {\n      lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);\n    }\n\n    if (subscribers.length === 0) {\n      return;\n    }\n\n    var child,\n        callback,\n        detail = promise._result;\n\n    for (var i = 0; i < subscribers.length; i += 3) {\n      child = subscribers[i];\n      callback = subscribers[i + settled];\n\n      if (child) {\n        lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);\n      } else {\n        callback(detail);\n      }\n    }\n\n    promise._subscribers.length = 0;\n  }\n\n  function lib$rsvp$$internal$$ErrorObject() {\n    this.error = null;\n  }\n\n  var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n  function lib$rsvp$$internal$$tryCatch(callback, detail) {\n    try {\n      return callback(detail);\n    } catch (e) {\n      lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;\n      return lib$rsvp$$internal$$TRY_CATCH_ERROR;\n    }\n  }\n\n  function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {\n    var hasCallback = lib$rsvp$utils$$isFunction(callback),\n        value,\n        error,\n        succeeded,\n        failed;\n\n    if (hasCallback) {\n      value = lib$rsvp$$internal$$tryCatch(callback, detail);\n\n      if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {\n        failed = true;\n        error = value.error;\n        value = null;\n      } else {\n        succeeded = true;\n      }\n\n      if (promise === value) {\n        lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());\n        return;\n      }\n    } else {\n      value = detail;\n      succeeded = true;\n    }\n\n    if (promise._state !== lib$rsvp$$internal$$PENDING) {// noop\n    } else if (hasCallback && succeeded) {\n      lib$rsvp$$internal$$resolve(promise, value);\n    } else if (failed) {\n      lib$rsvp$$internal$$reject(promise, error);\n    } else if (settled === lib$rsvp$$internal$$FULFILLED) {\n      lib$rsvp$$internal$$fulfill(promise, value);\n    } else if (settled === lib$rsvp$$internal$$REJECTED) {\n      lib$rsvp$$internal$$reject(promise, value);\n    }\n  }\n\n  function lib$rsvp$$internal$$initializePromise(promise, resolver) {\n    var resolved = false;\n\n    try {\n      resolver(function resolvePromise(value) {\n        if (resolved) {\n          return;\n        }\n\n        resolved = true;\n        lib$rsvp$$internal$$resolve(promise, value);\n      }, function rejectPromise(reason) {\n        if (resolved) {\n          return;\n        }\n\n        resolved = true;\n        lib$rsvp$$internal$$reject(promise, reason);\n      });\n    } catch (e) {\n      lib$rsvp$$internal$$reject(promise, e);\n    }\n  }\n\n  function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {\n    if (state === lib$rsvp$$internal$$FULFILLED) {\n      return {\n        state: 'fulfilled',\n        value: value\n      };\n    } else {\n      return {\n        state: 'rejected',\n        reason: value\n      };\n    }\n  }\n\n  function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n    var enumerator = this;\n    enumerator._instanceConstructor = Constructor;\n    enumerator.promise = new Constructor(lib$rsvp$$internal$$noop, label);\n    enumerator._abortOnReject = abortOnReject;\n\n    if (enumerator._validateInput(input)) {\n      enumerator._input = input;\n      enumerator.length = input.length;\n      enumerator._remaining = input.length;\n\n      enumerator._init();\n\n      if (enumerator.length === 0) {\n        lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n      } else {\n        enumerator.length = enumerator.length || 0;\n\n        enumerator._enumerate();\n\n        if (enumerator._remaining === 0) {\n          lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n        }\n      }\n    } else {\n      lib$rsvp$$internal$$reject(enumerator.promise, enumerator._validationError());\n    }\n  }\n\n  var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;\n\n  lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function (input) {\n    return lib$rsvp$utils$$isArray(input);\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._validationError = function () {\n    return new Error('Array Methods must be provided an Array');\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._init = function () {\n    this._result = new Array(this.length);\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function () {\n    var enumerator = this;\n    var length = enumerator.length;\n    var promise = enumerator.promise;\n    var input = enumerator._input;\n\n    for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n      enumerator._eachEntry(input[i], i);\n    }\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function (entry, i) {\n    var enumerator = this;\n    var c = enumerator._instanceConstructor;\n\n    if (lib$rsvp$utils$$isMaybeThenable(entry)) {\n      if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {\n        entry._onError = null;\n\n        enumerator._settledAt(entry._state, i, entry._result);\n      } else {\n        enumerator._willSettleAt(c.resolve(entry), i);\n      }\n    } else {\n      enumerator._remaining--;\n      enumerator._result[i] = enumerator._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);\n    }\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function (state, i, value) {\n    var enumerator = this;\n    var promise = enumerator.promise;\n\n    if (promise._state === lib$rsvp$$internal$$PENDING) {\n      enumerator._remaining--;\n\n      if (enumerator._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {\n        lib$rsvp$$internal$$reject(promise, value);\n      } else {\n        enumerator._result[i] = enumerator._makeResult(state, i, value);\n      }\n    }\n\n    if (enumerator._remaining === 0) {\n      lib$rsvp$$internal$$fulfill(promise, enumerator._result);\n    }\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function (state, i, value) {\n    return value;\n  };\n\n  lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function (promise, i) {\n    var enumerator = this;\n    lib$rsvp$$internal$$subscribe(promise, undefined, function (value) {\n      enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);\n    }, function (reason) {\n      enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);\n    });\n  };\n\n  function lib$rsvp$promise$all$$all(entries, label) {\n    return new lib$rsvp$enumerator$$default(this, entries, true\n    /* abort on reject */\n    , label).promise;\n  }\n\n  var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;\n\n  function lib$rsvp$promise$race$$race(entries, label) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\n    if (!lib$rsvp$utils$$isArray(entries)) {\n      lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n      return promise;\n    }\n\n    var length = entries.length;\n\n    function onFulfillment(value) {\n      lib$rsvp$$internal$$resolve(promise, value);\n    }\n\n    function onRejection(reason) {\n      lib$rsvp$$internal$$reject(promise, reason);\n    }\n\n    for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n      lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n    }\n\n    return promise;\n  }\n\n  var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;\n\n  function lib$rsvp$promise$resolve$$resolve(object, label) {\n    /*jshint validthis:true */\n    var Constructor = this;\n\n    if (object && typeof object === 'object' && object.constructor === Constructor) {\n      return object;\n    }\n\n    var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n    lib$rsvp$$internal$$resolve(promise, object);\n    return promise;\n  }\n\n  var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;\n\n  function lib$rsvp$promise$reject$$reject(reason, label) {\n    /*jshint validthis:true */\n    var Constructor = this;\n    var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n    lib$rsvp$$internal$$reject(promise, reason);\n    return promise;\n  }\n\n  var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;\n  var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';\n  var lib$rsvp$promise$$counter = 0;\n\n  function lib$rsvp$promise$$needsResolver() {\n    throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n  }\n\n  function lib$rsvp$promise$$needsNew() {\n    throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n  }\n\n  function lib$rsvp$promise$$Promise(resolver, label) {\n    var promise = this;\n    promise._id = lib$rsvp$promise$$counter++;\n    promise._label = label;\n    promise._state = undefined;\n    promise._result = undefined;\n    promise._subscribers = [];\n\n    if (lib$rsvp$config$$config.instrument) {\n      lib$rsvp$instrument$$default('created', promise);\n    }\n\n    if (lib$rsvp$$internal$$noop !== resolver) {\n      if (!lib$rsvp$utils$$isFunction(resolver)) {\n        lib$rsvp$promise$$needsResolver();\n      }\n\n      if (!(promise instanceof lib$rsvp$promise$$Promise)) {\n        lib$rsvp$promise$$needsNew();\n      }\n\n      lib$rsvp$$internal$$initializePromise(promise, resolver);\n    }\n  }\n\n  var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise; // deprecated\n\n  lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;\n  lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;\n  lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;\n  lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;\n  lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;\n  lib$rsvp$promise$$Promise.prototype = {\n    constructor: lib$rsvp$promise$$Promise,\n    _guidKey: lib$rsvp$promise$$guidKey,\n    _onError: function _onError(reason) {\n      var promise = this;\n      lib$rsvp$config$$config.after(function () {\n        if (promise._onError) {\n          lib$rsvp$config$$config['trigger']('error', reason);\n        }\n      });\n    },\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n       ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n       Chaining\n      --------\n       The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n       ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n       findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n       ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n       Assimilation\n      ------------\n       Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n       If the assimliated promise rejects, then the downstream promise will also reject.\n       ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n       Simple Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var result;\n       try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n       Advanced Example\n      --------------\n       Synchronous Example\n       ```javascript\n      var author, books;\n       try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n       Errback Example\n       ```js\n       function foundBooks(books) {\n       }\n       function failure(reason) {\n       }\n       findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n       Promise Example;\n       ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method then\n      @param {Function} onFulfillment\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n    then: function then(onFulfillment, onRejection, label) {\n      var parent = this;\n      var state = parent._state;\n\n      if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {\n        if (lib$rsvp$config$$config.instrument) {\n          lib$rsvp$instrument$$default('chained', parent, parent);\n        }\n\n        return parent;\n      }\n\n      parent._onError = null;\n      var child = new parent.constructor(lib$rsvp$$internal$$noop, label);\n      var result = parent._result;\n\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default('chained', parent, child);\n      }\n\n      if (state) {\n        var callback = arguments[state - 1];\n        lib$rsvp$config$$config.async(function () {\n          lib$rsvp$$internal$$invokeCallback(state, child, callback, result);\n        });\n      } else {\n        lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n      }\n\n      return child;\n    },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n       ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n       // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n       // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n       @method catch\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n    'catch': function _catch(onRejection, label) {\n      return this.then(undefined, onRejection, label);\n    },\n\n    /**\n      `finally` will be invoked regardless of the promise's fate just as native\n      try/catch/finally behaves\n       Synchronous example:\n       ```js\n      findAuthor() {\n        if (Math.random() > 0.5) {\n          throw new Error();\n        }\n        return new Author();\n      }\n       try {\n        return findAuthor(); // succeed or fail\n      } catch(error) {\n        return findOtherAuther();\n      } finally {\n        // always runs\n        // doesn't affect the return value\n      }\n      ```\n       Asynchronous example:\n       ```js\n      findAuthor().catch(function(reason){\n        return findOtherAuther();\n      }).finally(function(){\n        // author was either found, or not\n      });\n      ```\n       @method finally\n      @param {Function} callback\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n    'finally': function _finally(callback, label) {\n      var promise = this;\n      var constructor = promise.constructor;\n      return promise.then(function (value) {\n        return constructor.resolve(callback()).then(function () {\n          return value;\n        });\n      }, function (reason) {\n        return constructor.resolve(callback()).then(function () {\n          throw reason;\n        });\n      }, label);\n    }\n  };\n\n  function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {\n    this._superConstructor(Constructor, entries, false\n    /* don't abort on reject */\n    , label);\n  }\n\n  lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n  lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n  lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\n  lib$rsvp$all$settled$$AllSettled.prototype._validationError = function () {\n    return new Error('allSettled must be called with an array');\n  };\n\n  function lib$rsvp$all$settled$$allSettled(entries, label) {\n    return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;\n  }\n\n  var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;\n\n  function lib$rsvp$all$$all(array, label) {\n    return lib$rsvp$promise$$default.all(array, label);\n  }\n\n  var lib$rsvp$all$$default = lib$rsvp$all$$all;\n  var lib$rsvp$asap$$len = 0;\n  var lib$rsvp$asap$$toString = {}.toString;\n  var lib$rsvp$asap$$vertxNext;\n\n  function lib$rsvp$asap$$asap(callback, arg) {\n    lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;\n    lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;\n    lib$rsvp$asap$$len += 2;\n\n    if (lib$rsvp$asap$$len === 2) {\n      // If len is 1, that means that we need to schedule an async flush.\n      // If additional callbacks are queued before the queue is flushed, they\n      // will be processed by this flush that we are scheduling.\n      lib$rsvp$asap$$scheduleFlush();\n    }\n  }\n\n  var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;\n  var lib$rsvp$asap$$browserWindow = typeof window !== 'undefined' ? window : undefined;\n  var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};\n  var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;\n  var lib$rsvp$asap$$isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]'; // test for web worker but not in IE10\n\n  var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined'; // node\n\n  function lib$rsvp$asap$$useNextTick() {\n    var nextTick = process.nextTick; // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n    // setImmediate should be used instead instead\n\n    var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n\n    if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n      nextTick = setImmediate;\n    }\n\n    return function () {\n      nextTick(lib$rsvp$asap$$flush);\n    };\n  } // vertx\n\n\n  function lib$rsvp$asap$$useVertxTimer() {\n    return function () {\n      lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);\n    };\n  }\n\n  function lib$rsvp$asap$$useMutationObserver() {\n    var iterations = 0;\n    var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);\n    var node = document.createTextNode('');\n    observer.observe(node, {\n      characterData: true\n    });\n    return function () {\n      node.data = iterations = ++iterations % 2;\n    };\n  } // web worker\n\n\n  function lib$rsvp$asap$$useMessageChannel() {\n    var channel = new MessageChannel();\n    channel.port1.onmessage = lib$rsvp$asap$$flush;\n    return function () {\n      channel.port2.postMessage(0);\n    };\n  }\n\n  function lib$rsvp$asap$$useSetTimeout() {\n    return function () {\n      setTimeout(lib$rsvp$asap$$flush, 1);\n    };\n  }\n\n  var lib$rsvp$asap$$queue = new Array(1000);\n\n  function lib$rsvp$asap$$flush() {\n    for (var i = 0; i < lib$rsvp$asap$$len; i += 2) {\n      var callback = lib$rsvp$asap$$queue[i];\n      var arg = lib$rsvp$asap$$queue[i + 1];\n      callback(arg);\n      lib$rsvp$asap$$queue[i] = undefined;\n      lib$rsvp$asap$$queue[i + 1] = undefined;\n    }\n\n    lib$rsvp$asap$$len = 0;\n  }\n\n  function lib$rsvp$asap$$attemptVertex() {\n    try {\n      var r = require;\n      var vertx = r('vertx');\n      lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n      return lib$rsvp$asap$$useVertxTimer();\n    } catch (e) {\n      return lib$rsvp$asap$$useSetTimeout();\n    }\n  }\n\n  var lib$rsvp$asap$$scheduleFlush; // Decide what async method to use to triggering processing of queued callbacks:\n\n  if (lib$rsvp$asap$$isNode) {\n    lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();\n  } else if (lib$rsvp$asap$$BrowserMutationObserver) {\n    lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();\n  } else if (lib$rsvp$asap$$isWorker) {\n    lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();\n  } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {\n    lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();\n  } else {\n    lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();\n  }\n\n  function lib$rsvp$defer$$defer(label) {\n    var deferred = {};\n    deferred['promise'] = new lib$rsvp$promise$$default(function (resolve, reject) {\n      deferred['resolve'] = resolve;\n      deferred['reject'] = reject;\n    }, label);\n    return deferred;\n  }\n\n  var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;\n\n  function lib$rsvp$filter$$filter(promises, filterFn, label) {\n    return lib$rsvp$promise$$default.all(promises, label).then(function (values) {\n      if (!lib$rsvp$utils$$isFunction(filterFn)) {\n        throw new TypeError(\"You must pass a function as filter's second argument.\");\n      }\n\n      var length = values.length;\n      var filtered = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        filtered[i] = filterFn(values[i]);\n      }\n\n      return lib$rsvp$promise$$default.all(filtered, label).then(function (filtered) {\n        var results = new Array(length);\n        var newLength = 0;\n\n        for (var i = 0; i < length; i++) {\n          if (filtered[i]) {\n            results[newLength] = values[i];\n            newLength++;\n          }\n        }\n\n        results.length = newLength;\n        return results;\n      });\n    });\n  }\n\n  var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;\n\n  function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {\n    this._superConstructor(Constructor, object, true, label);\n  }\n\n  var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;\n  lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n  lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;\n\n  lib$rsvp$promise$hash$$PromiseHash.prototype._init = function () {\n    this._result = {};\n  };\n\n  lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function (input) {\n    return input && typeof input === 'object';\n  };\n\n  lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function () {\n    return new Error('Promise.hash must be called with an object');\n  };\n\n  lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function () {\n    var enumerator = this;\n    var promise = enumerator.promise;\n    var input = enumerator._input;\n    var results = [];\n\n    for (var key in input) {\n      if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {\n        results.push({\n          position: key,\n          entry: input[key]\n        });\n      }\n    }\n\n    var length = results.length;\n    enumerator._remaining = length;\n    var result;\n\n    for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n      result = results[i];\n\n      enumerator._eachEntry(result.entry, result.position);\n    }\n  };\n\n  function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {\n    this._superConstructor(Constructor, object, false, label);\n  }\n\n  lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);\n  lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n  lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\n  lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function () {\n    return new Error('hashSettled must be called with an object');\n  };\n\n  function lib$rsvp$hash$settled$$hashSettled(object, label) {\n    return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;\n  }\n\n  var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;\n\n  function lib$rsvp$hash$$hash(object, label) {\n    return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;\n  }\n\n  var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;\n\n  function lib$rsvp$map$$map(promises, mapFn, label) {\n    return lib$rsvp$promise$$default.all(promises, label).then(function (values) {\n      if (!lib$rsvp$utils$$isFunction(mapFn)) {\n        throw new TypeError(\"You must pass a function as map's second argument.\");\n      }\n\n      var length = values.length;\n      var results = new Array(length);\n\n      for (var i = 0; i < length; i++) {\n        results[i] = mapFn(values[i]);\n      }\n\n      return lib$rsvp$promise$$default.all(results, label);\n    });\n  }\n\n  var lib$rsvp$map$$default = lib$rsvp$map$$map;\n\n  function lib$rsvp$node$$Result() {\n    this.value = undefined;\n  }\n\n  var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();\n  var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();\n\n  function lib$rsvp$node$$getThen(obj) {\n    try {\n      return obj.then;\n    } catch (error) {\n      lib$rsvp$node$$ERROR.value = error;\n      return lib$rsvp$node$$ERROR;\n    }\n  }\n\n  function lib$rsvp$node$$tryApply(f, s, a) {\n    try {\n      f.apply(s, a);\n    } catch (error) {\n      lib$rsvp$node$$ERROR.value = error;\n      return lib$rsvp$node$$ERROR;\n    }\n  }\n\n  function lib$rsvp$node$$makeObject(_, argumentNames) {\n    var obj = {};\n    var name;\n    var i;\n    var length = _.length;\n    var args = new Array(length);\n\n    for (var x = 0; x < length; x++) {\n      args[x] = _[x];\n    }\n\n    for (i = 0; i < argumentNames.length; i++) {\n      name = argumentNames[i];\n      obj[name] = args[i + 1];\n    }\n\n    return obj;\n  }\n\n  function lib$rsvp$node$$arrayResult(_) {\n    var length = _.length;\n    var args = new Array(length - 1);\n\n    for (var i = 1; i < length; i++) {\n      args[i - 1] = _[i];\n    }\n\n    return args;\n  }\n\n  function lib$rsvp$node$$wrapThenable(_then, promise) {\n    return {\n      then: function then(onFulFillment, onRejection) {\n        return _then.call(promise, onFulFillment, onRejection);\n      }\n    };\n  }\n\n  function lib$rsvp$node$$denodeify(nodeFunc, options) {\n    var fn = function fn() {\n      var self = this;\n      var l = arguments.length;\n      var args = new Array(l + 1);\n      var arg;\n      var promiseInput = false;\n\n      for (var i = 0; i < l; ++i) {\n        arg = arguments[i];\n\n        if (!promiseInput) {\n          // TODO: clean this up\n          promiseInput = lib$rsvp$node$$needsPromiseInput(arg);\n\n          if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {\n            var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n            lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);\n            return p;\n          } else if (promiseInput && promiseInput !== true) {\n            arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);\n          }\n        }\n\n        args[i] = arg;\n      }\n\n      var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n\n      args[l] = function (err, val) {\n        if (err) lib$rsvp$$internal$$reject(promise, err);else if (options === undefined) lib$rsvp$$internal$$resolve(promise, val);else if (options === true) lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));else if (lib$rsvp$utils$$isArray(options)) lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));else lib$rsvp$$internal$$resolve(promise, val);\n      };\n\n      if (promiseInput) {\n        return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);\n      } else {\n        return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);\n      }\n    };\n\n    fn.__proto__ = nodeFunc;\n    return fn;\n  }\n\n  var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;\n\n  function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {\n    var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n\n    if (result === lib$rsvp$node$$ERROR) {\n      lib$rsvp$$internal$$reject(promise, result.value);\n    }\n\n    return promise;\n  }\n\n  function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self) {\n    return lib$rsvp$promise$$default.all(args).then(function (args) {\n      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n\n      if (result === lib$rsvp$node$$ERROR) {\n        lib$rsvp$$internal$$reject(promise, result.value);\n      }\n\n      return promise;\n    });\n  }\n\n  function lib$rsvp$node$$needsPromiseInput(arg) {\n    if (arg && typeof arg === 'object') {\n      if (arg.constructor === lib$rsvp$promise$$default) {\n        return true;\n      } else {\n        return lib$rsvp$node$$getThen(arg);\n      }\n    } else {\n      return false;\n    }\n  }\n\n  var lib$rsvp$platform$$platform;\n  /* global self */\n\n  if (typeof self === 'object') {\n    lib$rsvp$platform$$platform = self;\n    /* global global */\n  } else if (typeof global === 'object') {\n    lib$rsvp$platform$$platform = global;\n  } else {\n    throw new Error('no global: `self` or `global` found');\n  }\n\n  var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;\n\n  function lib$rsvp$race$$race(array, label) {\n    return lib$rsvp$promise$$default.race(array, label);\n  }\n\n  var lib$rsvp$race$$default = lib$rsvp$race$$race;\n\n  function lib$rsvp$reject$$reject(reason, label) {\n    return lib$rsvp$promise$$default.reject(reason, label);\n  }\n\n  var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;\n\n  function lib$rsvp$resolve$$resolve(value, label) {\n    return lib$rsvp$promise$$default.resolve(value, label);\n  }\n\n  var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;\n\n  function lib$rsvp$rethrow$$rethrow(reason) {\n    setTimeout(function () {\n      throw reason;\n    });\n    throw reason;\n  }\n\n  var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow; // defaults\n\n  lib$rsvp$config$$config.async = lib$rsvp$asap$$default;\n\n  lib$rsvp$config$$config.after = function (cb) {\n    setTimeout(cb, 0);\n  };\n\n  var lib$rsvp$$cast = lib$rsvp$resolve$$default;\n\n  function lib$rsvp$$async(callback, arg) {\n    lib$rsvp$config$$config.async(callback, arg);\n  }\n\n  function lib$rsvp$$on() {\n    lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);\n  }\n\n  function lib$rsvp$$off() {\n    lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);\n  } // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`\n\n\n  if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {\n    var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];\n    lib$rsvp$config$$configure('instrument', true);\n\n    for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {\n      if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {\n        lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);\n      }\n    }\n  }\n\n  var lib$rsvp$umd$$RSVP = {\n    'race': lib$rsvp$race$$default,\n    'Promise': lib$rsvp$promise$$default,\n    'allSettled': lib$rsvp$all$settled$$default,\n    'hash': lib$rsvp$hash$$default,\n    'hashSettled': lib$rsvp$hash$settled$$default,\n    'denodeify': lib$rsvp$node$$default,\n    'on': lib$rsvp$$on,\n    'off': lib$rsvp$$off,\n    'map': lib$rsvp$map$$default,\n    'filter': lib$rsvp$filter$$default,\n    'resolve': lib$rsvp$resolve$$default,\n    'reject': lib$rsvp$reject$$default,\n    'all': lib$rsvp$all$$default,\n    'rethrow': lib$rsvp$rethrow$$default,\n    'defer': lib$rsvp$defer$$default,\n    'EventTarget': lib$rsvp$events$$default,\n    'configure': lib$rsvp$config$$configure,\n    'async': lib$rsvp$$async\n  };\n  /* global define:true module:true window: true */\n\n  if (typeof define === 'function' && define['amd']) {\n    define(function () {\n      return lib$rsvp$umd$$RSVP;\n    });\n  } else if (typeof module !== 'undefined' && module['exports']) {\n    module['exports'] = lib$rsvp$umd$$RSVP;\n  } else if (typeof lib$rsvp$platform$$default !== 'undefined') {\n    lib$rsvp$platform$$default['RSVP'] = lib$rsvp$umd$$RSVP;\n  }\n}).call(this);","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/rsvp/dist/rsvp.js"],"names":["lib$rsvp$utils$$objectOrFunction","x","lib$rsvp$utils$$isFunction","lib$rsvp$utils$$isMaybeThenable","lib$rsvp$utils$$_isArray","Array","isArray","Object","prototype","toString","call","lib$rsvp$utils$$isArray","lib$rsvp$utils$$now","Date","now","getTime","lib$rsvp$utils$$F","lib$rsvp$utils$$o_create","create","o","arguments","length","Error","TypeError","lib$rsvp$events$$indexOf","callbacks","callback","i","l","lib$rsvp$events$$callbacksFor","object","_promiseCallbacks","lib$rsvp$events$$default","undefined","eventName","allCallbacks","push","index","splice","options","lib$rsvp$config$$config","instrument","lib$rsvp$config$$configure","name","value","lib$rsvp$instrument$$queue","lib$rsvp$instrument$$scheduleFlush","setTimeout","entry","payload","guid","key","id","childGuid","childId","error","stack","lib$rsvp$instrument$$instrument","promise","child","_guidKey","_id","detail","_result","label","_label","timeStamp","lib$rsvp$instrument$$default","lib$rsvp$$internal$$withOwnPromise","lib$rsvp$$internal$$noop","lib$rsvp$$internal$$PENDING","lib$rsvp$$internal$$FULFILLED","lib$rsvp$$internal$$REJECTED","lib$rsvp$$internal$$GET_THEN_ERROR","lib$rsvp$$internal$$ErrorObject","lib$rsvp$$internal$$getThen","then","lib$rsvp$$internal$$tryThen","fulfillmentHandler","rejectionHandler","e","lib$rsvp$$internal$$handleForeignThenable","thenable","async","sealed","lib$rsvp$$internal$$resolve","lib$rsvp$$internal$$fulfill","reason","lib$rsvp$$internal$$reject","lib$rsvp$$internal$$handleOwnThenable","_state","_onError","lib$rsvp$$internal$$subscribe","lib$rsvp$$internal$$handleMaybeThenable","maybeThenable","constructor","lib$rsvp$$internal$$publishRejection","lib$rsvp$$internal$$publish","_subscribers","parent","onFulfillment","onRejection","subscribers","settled","lib$rsvp$$internal$$invokeCallback","lib$rsvp$$internal$$TRY_CATCH_ERROR","lib$rsvp$$internal$$tryCatch","hasCallback","succeeded","failed","lib$rsvp$$internal$$initializePromise","resolver","resolved","resolvePromise","rejectPromise","lib$rsvp$enumerator$$makeSettledResult","state","position","lib$rsvp$enumerator$$Enumerator","Constructor","input","abortOnReject","enumerator","_instanceConstructor","_abortOnReject","_validateInput","_input","_remaining","_init","_enumerate","_validationError","lib$rsvp$enumerator$$default","_eachEntry","c","_settledAt","_willSettleAt","resolve","_makeResult","lib$rsvp$promise$all$$all","entries","lib$rsvp$promise$all$$default","lib$rsvp$promise$race$$race","lib$rsvp$promise$race$$default","lib$rsvp$promise$resolve$$resolve","lib$rsvp$promise$resolve$$default","lib$rsvp$promise$reject$$reject","lib$rsvp$promise$reject$$default","lib$rsvp$promise$$guidKey","lib$rsvp$promise$$counter","lib$rsvp$promise$$needsResolver","lib$rsvp$promise$$needsNew","lib$rsvp$promise$$Promise","lib$rsvp$promise$$default","cast","all","race","reject","after","result","lib$rsvp$all$settled$$AllSettled","_superConstructor","lib$rsvp$all$settled$$allSettled","lib$rsvp$all$settled$$default","lib$rsvp$all$$all","array","lib$rsvp$all$$default","lib$rsvp$asap$$len","lib$rsvp$asap$$toString","lib$rsvp$asap$$vertxNext","lib$rsvp$asap$$asap","arg","lib$rsvp$asap$$queue","lib$rsvp$asap$$scheduleFlush","lib$rsvp$asap$$default","lib$rsvp$asap$$browserWindow","window","lib$rsvp$asap$$browserGlobal","lib$rsvp$asap$$BrowserMutationObserver","MutationObserver","WebKitMutationObserver","lib$rsvp$asap$$isNode","self","process","lib$rsvp$asap$$isWorker","Uint8ClampedArray","importScripts","MessageChannel","lib$rsvp$asap$$useNextTick","nextTick","version","versions","node","match","setImmediate","lib$rsvp$asap$$flush","lib$rsvp$asap$$useVertxTimer","lib$rsvp$asap$$useMutationObserver","iterations","observer","document","createTextNode","observe","characterData","data","lib$rsvp$asap$$useMessageChannel","channel","port1","onmessage","port2","postMessage","lib$rsvp$asap$$useSetTimeout","lib$rsvp$asap$$attemptVertex","r","require","vertx","runOnLoop","runOnContext","lib$rsvp$defer$$defer","deferred","lib$rsvp$defer$$default","lib$rsvp$filter$$filter","promises","filterFn","values","filtered","results","newLength","lib$rsvp$filter$$default","lib$rsvp$promise$hash$$PromiseHash","lib$rsvp$promise$hash$$default","hasOwnProperty","lib$rsvp$hash$settled$$HashSettled","lib$rsvp$hash$settled$$hashSettled","lib$rsvp$hash$settled$$default","lib$rsvp$hash$$hash","lib$rsvp$hash$$default","lib$rsvp$map$$map","mapFn","lib$rsvp$map$$default","lib$rsvp$node$$Result","lib$rsvp$node$$ERROR","lib$rsvp$node$$GET_THEN_ERROR","lib$rsvp$node$$getThen","obj","lib$rsvp$node$$tryApply","f","s","a","apply","lib$rsvp$node$$makeObject","_","argumentNames","args","lib$rsvp$node$$arrayResult","lib$rsvp$node$$wrapThenable","onFulFillment","lib$rsvp$node$$denodeify","nodeFunc","fn","promiseInput","lib$rsvp$node$$needsPromiseInput","p","err","val","lib$rsvp$node$$handlePromiseInput","lib$rsvp$node$$handleValueInput","__proto__","lib$rsvp$node$$default","lib$rsvp$platform$$platform","global","lib$rsvp$platform$$default","lib$rsvp$race$$race","lib$rsvp$race$$default","lib$rsvp$reject$$reject","lib$rsvp$reject$$default","lib$rsvp$resolve$$resolve","lib$rsvp$resolve$$default","lib$rsvp$rethrow$$rethrow","lib$rsvp$rethrow$$default","cb","lib$rsvp$$cast","lib$rsvp$$async","lib$rsvp$$on","lib$rsvp$$off","lib$rsvp$$callbacks","lib$rsvp$$eventName","lib$rsvp$umd$$RSVP","define","module"],"mappings":"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AAAA,yBAAyB,CAAC/I,SAA1B,GAAsC;AACpCuF,IAAAA,WAAW,EAAEwD,yBADuB;AAGpC3F,IAAAA,QAAQ,EAAEuF,yBAH0B;AAKpCxD,IAAAA,QAAQ,EAAE,kBAAUJ,MAAV,EAAkB;AAC1B,UAAI7B,OAAO,GAAG,IAAd;AACAlB,MAAAA,uBAAuB,CAACqH,KAAxB,CAA8B,YAAW;AACvC,YAAInG,OAAO,CAACiC,QAAZ,EAAsB;AACpBnD,UAAAA,uBAAuB,CAAC,SAAD,CAAvB,CAAmC,OAAnC,EAA4C+C,MAA5C;AACD;AACF,OAJD;AAKD,KAZmC;;AActC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkCMX,IAAAA,IAAI,EAAE,cAASwB,aAAT,EAAwBC,WAAxB,EAAqCrC,K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","sourcesContent":["/*!\n * @overview RSVP - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/tildeio/rsvp.js/master/LICENSE\n * @version   3.0.21\n */\n\n(function() {\n    \"use strict\";\n    function lib$rsvp$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$rsvp$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$rsvp$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$rsvp$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$rsvp$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$rsvp$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$rsvp$utils$$isArray = lib$rsvp$utils$$_isArray;\n\n    var lib$rsvp$utils$$now = Date.now || function() { return new Date().getTime(); };\n\n    function lib$rsvp$utils$$F() { }\n\n    var lib$rsvp$utils$$o_create = (Object.create || function (o) {\n      if (arguments.length > 1) {\n        throw new Error('Second argument not supported');\n      }\n      if (typeof o !== 'object') {\n        throw new TypeError('Argument must be an object');\n      }\n      lib$rsvp$utils$$F.prototype = o;\n      return new lib$rsvp$utils$$F();\n    });\n    function lib$rsvp$events$$indexOf(callbacks, callback) {\n      for (var i=0, l=callbacks.length; i<l; i++) {\n        if (callbacks[i] === callback) { return i; }\n      }\n\n      return -1;\n    }\n\n    function lib$rsvp$events$$callbacksFor(object) {\n      var callbacks = object._promiseCallbacks;\n\n      if (!callbacks) {\n        callbacks = object._promiseCallbacks = {};\n      }\n\n      return callbacks;\n    }\n\n    var lib$rsvp$events$$default = {\n\n      /**\n        `RSVP.EventTarget.mixin` extends an object with EventTarget methods. For\n        Example:\n\n        ```javascript\n        var object = {};\n\n        RSVP.EventTarget.mixin(object);\n\n        object.on('finished', function(event) {\n          // handle event\n        });\n\n        object.trigger('finished', { detail: value });\n        ```\n\n        `EventTarget.mixin` also works with prototypes:\n\n        ```javascript\n        var Person = function() {};\n        RSVP.EventTarget.mixin(Person.prototype);\n\n        var yehuda = new Person();\n        var tom = new Person();\n\n        yehuda.on('poke', function(event) {\n          console.log('Yehuda says OW');\n        });\n\n        tom.on('poke', function(event) {\n          console.log('Tom says OW');\n        });\n\n        yehuda.trigger('poke');\n        tom.trigger('poke');\n        ```\n\n        @method mixin\n        @for RSVP.EventTarget\n        @private\n        @param {Object} object object to extend with EventTarget methods\n      */\n      'mixin': function(object) {\n        object['on']      = this['on'];\n        object['off']     = this['off'];\n        object['trigger'] = this['trigger'];\n        object._promiseCallbacks = undefined;\n        return object;\n      },\n\n      /**\n        Registers a callback to be executed when `eventName` is triggered\n\n        ```javascript\n        object.on('event', function(eventInfo){\n          // handle the event\n        });\n\n        object.trigger('event');\n        ```\n\n        @method on\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to listen for\n        @param {Function} callback function to be called when the event is triggered.\n      */\n      'on': function(eventName, callback) {\n        if (typeof callback !== 'function') {\n          throw new TypeError('Callback must be a function');\n        }\n\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks;\n\n        callbacks = allCallbacks[eventName];\n\n        if (!callbacks) {\n          callbacks = allCallbacks[eventName] = [];\n        }\n\n        if (lib$rsvp$events$$indexOf(callbacks, callback) === -1) {\n          callbacks.push(callback);\n        }\n      },\n\n      /**\n        You can use `off` to stop firing a particular callback for an event:\n\n        ```javascript\n        function doStuff() { // do stuff! }\n        object.on('stuff', doStuff);\n\n        object.trigger('stuff'); // doStuff will be called\n\n        // Unregister ONLY the doStuff callback\n        object.off('stuff', doStuff);\n        object.trigger('stuff'); // doStuff will NOT be called\n        ```\n\n        If you don't pass a `callback` argument to `off`, ALL callbacks for the\n        event will not be executed when the event fires. For example:\n\n        ```javascript\n        var callback1 = function(){};\n        var callback2 = function(){};\n\n        object.on('stuff', callback1);\n        object.on('stuff', callback2);\n\n        object.trigger('stuff'); // callback1 and callback2 will be executed.\n\n        object.off('stuff');\n        object.trigger('stuff'); // callback1 and callback2 will not be executed!\n        ```\n\n        @method off\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName event to stop listening to\n        @param {Function} callback optional argument. If given, only the function\n        given will be removed from the event's callback queue. If no `callback`\n        argument is given, all callbacks will be removed from the event's callback\n        queue.\n      */\n      'off': function(eventName, callback) {\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, index;\n\n        if (!callback) {\n          allCallbacks[eventName] = [];\n          return;\n        }\n\n        callbacks = allCallbacks[eventName];\n\n        index = lib$rsvp$events$$indexOf(callbacks, callback);\n\n        if (index !== -1) { callbacks.splice(index, 1); }\n      },\n\n      /**\n        Use `trigger` to fire custom events. For example:\n\n        ```javascript\n        object.on('foo', function(){\n          console.log('foo event happened!');\n        });\n        object.trigger('foo');\n        // 'foo event happened!' logged to the console\n        ```\n\n        You can also pass a value as a second argument to `trigger` that will be\n        passed as an argument to all event listeners for the event:\n\n        ```javascript\n        object.on('foo', function(value){\n          console.log(value.name);\n        });\n\n        object.trigger('foo', { name: 'bar' });\n        // 'bar' logged to the console\n        ```\n\n        @method trigger\n        @for RSVP.EventTarget\n        @private\n        @param {String} eventName name of the event to be triggered\n        @param {*} options optional value to be passed to any event handlers for\n        the given `eventName`\n      */\n      'trigger': function(eventName, options) {\n        var allCallbacks = lib$rsvp$events$$callbacksFor(this), callbacks, callback;\n\n        if (callbacks = allCallbacks[eventName]) {\n          // Don't cache the callbacks.length since it may grow\n          for (var i=0; i<callbacks.length; i++) {\n            callback = callbacks[i];\n\n            callback(options);\n          }\n        }\n      }\n    };\n\n    var lib$rsvp$config$$config = {\n      instrument: false\n    };\n\n    lib$rsvp$events$$default['mixin'](lib$rsvp$config$$config);\n\n    function lib$rsvp$config$$configure(name, value) {\n      if (name === 'onerror') {\n        // handle for legacy users that expect the actual\n        // error to be passed to their function added via\n        // `RSVP.configure('onerror', someFunctionHere);`\n        lib$rsvp$config$$config['on']('error', value);\n        return;\n      }\n\n      if (arguments.length === 2) {\n        lib$rsvp$config$$config[name] = value;\n      } else {\n        return lib$rsvp$config$$config[name];\n      }\n    }\n\n    var lib$rsvp$instrument$$queue = [];\n\n    function lib$rsvp$instrument$$scheduleFlush() {\n      setTimeout(function() {\n        var entry;\n        for (var i = 0; i < lib$rsvp$instrument$$queue.length; i++) {\n          entry = lib$rsvp$instrument$$queue[i];\n\n          var payload = entry.payload;\n\n          payload.guid = payload.key + payload.id;\n          payload.childGuid = payload.key + payload.childId;\n          if (payload.error) {\n            payload.stack = payload.error.stack;\n          }\n\n          lib$rsvp$config$$config['trigger'](entry.name, entry.payload);\n        }\n        lib$rsvp$instrument$$queue.length = 0;\n      }, 50);\n    }\n\n    function lib$rsvp$instrument$$instrument(eventName, promise, child) {\n      if (1 === lib$rsvp$instrument$$queue.push({\n        name: eventName,\n        payload: {\n          key: promise._guidKey,\n          id:  promise._id,\n          eventName: eventName,\n          detail: promise._result,\n          childId: child && child._id,\n          label: promise._label,\n          timeStamp: lib$rsvp$utils$$now(),\n          error: lib$rsvp$config$$config[\"instrument-with-stack\"] ? new Error(promise._label) : null\n        }})) {\n          lib$rsvp$instrument$$scheduleFlush();\n        }\n      }\n    var lib$rsvp$instrument$$default = lib$rsvp$instrument$$instrument;\n\n    function  lib$rsvp$$internal$$withOwnPromise() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$rsvp$$internal$$noop() {}\n\n    var lib$rsvp$$internal$$PENDING   = void 0;\n    var lib$rsvp$$internal$$FULFILLED = 1;\n    var lib$rsvp$$internal$$REJECTED  = 2;\n\n    var lib$rsvp$$internal$$GET_THEN_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n    function lib$rsvp$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$rsvp$$internal$$GET_THEN_ERROR.error = error;\n        return lib$rsvp$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$rsvp$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$rsvp$$internal$$handleForeignThenable(promise, thenable, then) {\n      lib$rsvp$config$$config.async(function(promise) {\n        var sealed = false;\n        var error = lib$rsvp$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$rsvp$$internal$$resolve(promise, value);\n          } else {\n            lib$rsvp$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$rsvp$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$rsvp$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$rsvp$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$rsvp$$internal$$FULFILLED) {\n        lib$rsvp$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$rsvp$$internal$$REJECTED) {\n        thenable._onError = null;\n        lib$rsvp$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$rsvp$$internal$$subscribe(thenable, undefined, function(value) {\n          if (thenable !== value) {\n            lib$rsvp$$internal$$resolve(promise, value);\n          } else {\n            lib$rsvp$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          lib$rsvp$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$rsvp$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$rsvp$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$rsvp$$internal$$getThen(maybeThenable);\n\n        if (then === lib$rsvp$$internal$$GET_THEN_ERROR) {\n          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$rsvp$utils$$isFunction(then)) {\n          lib$rsvp$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$rsvp$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$rsvp$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      } else if (lib$rsvp$utils$$objectOrFunction(value)) {\n        lib$rsvp$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$rsvp$$internal$$publishRejection(promise) {\n      if (promise._onError) {\n        promise._onError(promise._result);\n      }\n\n      lib$rsvp$$internal$$publish(promise);\n    }\n\n    function lib$rsvp$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$rsvp$$internal$$FULFILLED;\n\n      if (promise._subscribers.length === 0) {\n        if (lib$rsvp$config$$config.instrument) {\n          lib$rsvp$instrument$$default('fulfilled', promise);\n        }\n      } else {\n        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, promise);\n      }\n    }\n\n    function lib$rsvp$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$rsvp$$internal$$PENDING) { return; }\n      promise._state = lib$rsvp$$internal$$REJECTED;\n      promise._result = reason;\n      lib$rsvp$config$$config.async(lib$rsvp$$internal$$publishRejection, promise);\n    }\n\n    function lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onError = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$rsvp$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$rsvp$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$rsvp$config$$config.async(lib$rsvp$$internal$$publish, parent);\n      }\n    }\n\n    function lib$rsvp$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default(settled === lib$rsvp$$internal$$FULFILLED ? 'fulfilled' : 'rejected', promise);\n      }\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$rsvp$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$rsvp$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$rsvp$$internal$$TRY_CATCH_ERROR = new lib$rsvp$$internal$$ErrorObject();\n\n    function lib$rsvp$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$rsvp$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$rsvp$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$rsvp$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$rsvp$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$rsvp$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$rsvp$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$rsvp$$internal$$reject(promise, lib$rsvp$$internal$$withOwnPromise());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$rsvp$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$rsvp$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$rsvp$$internal$$reject(promise, error);\n      } else if (settled === lib$rsvp$$internal$$FULFILLED) {\n        lib$rsvp$$internal$$fulfill(promise, value);\n      } else if (settled === lib$rsvp$$internal$$REJECTED) {\n        lib$rsvp$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$rsvp$$internal$$initializePromise(promise, resolver) {\n      var resolved = false;\n      try {\n        resolver(function resolvePromise(value){\n          if (resolved) { return; }\n          resolved = true;\n          lib$rsvp$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          if (resolved) { return; }\n          resolved = true;\n          lib$rsvp$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$rsvp$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$rsvp$enumerator$$makeSettledResult(state, position, value) {\n      if (state === lib$rsvp$$internal$$FULFILLED) {\n        return {\n          state: 'fulfilled',\n          value: value\n        };\n      } else {\n         return {\n          state: 'rejected',\n          reason: value\n        };\n      }\n    }\n\n    function lib$rsvp$enumerator$$Enumerator(Constructor, input, abortOnReject, label) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      enumerator._abortOnReject = abortOnReject;\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$rsvp$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$rsvp$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    var lib$rsvp$enumerator$$default = lib$rsvp$enumerator$$Enumerator;\n\n    lib$rsvp$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$rsvp$utils$$isArray(input);\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n      var length     = enumerator.length;\n      var promise    = enumerator.promise;\n      var input      = enumerator._input;\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n      if (lib$rsvp$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$rsvp$$internal$$PENDING) {\n          entry._onError = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = enumerator._makeResult(lib$rsvp$$internal$$FULFILLED, i, entry);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$rsvp$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (enumerator._abortOnReject && state === lib$rsvp$$internal$$REJECTED) {\n          lib$rsvp$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = enumerator._makeResult(state, i, value);\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$rsvp$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._makeResult = function(state, i, value) {\n      return value;\n    };\n\n    lib$rsvp$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$rsvp$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$rsvp$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$rsvp$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$rsvp$promise$all$$all(entries, label) {\n      return new lib$rsvp$enumerator$$default(this, entries, true /* abort on reject */, label).promise;\n    }\n    var lib$rsvp$promise$all$$default = lib$rsvp$promise$all$$all;\n    function lib$rsvp$promise$race$$race(entries, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n\n      if (!lib$rsvp$utils$$isArray(entries)) {\n        lib$rsvp$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$rsvp$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$rsvp$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        lib$rsvp$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$rsvp$promise$race$$default = lib$rsvp$promise$race$$race;\n    function lib$rsvp$promise$resolve$$resolve(object, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      lib$rsvp$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$rsvp$promise$resolve$$default = lib$rsvp$promise$resolve$$resolve;\n    function lib$rsvp$promise$reject$$reject(reason, label) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$rsvp$$internal$$noop, label);\n      lib$rsvp$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$rsvp$promise$reject$$default = lib$rsvp$promise$reject$$reject;\n\n    var lib$rsvp$promise$$guidKey = 'rsvp_' + lib$rsvp$utils$$now() + '-';\n    var lib$rsvp$promise$$counter = 0;\n\n    function lib$rsvp$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$rsvp$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    function lib$rsvp$promise$$Promise(resolver, label) {\n      var promise = this;\n\n      promise._id = lib$rsvp$promise$$counter++;\n      promise._label = label;\n      promise._state = undefined;\n      promise._result = undefined;\n      promise._subscribers = [];\n\n      if (lib$rsvp$config$$config.instrument) {\n        lib$rsvp$instrument$$default('created', promise);\n      }\n\n      if (lib$rsvp$$internal$$noop !== resolver) {\n        if (!lib$rsvp$utils$$isFunction(resolver)) {\n          lib$rsvp$promise$$needsResolver();\n        }\n\n        if (!(promise instanceof lib$rsvp$promise$$Promise)) {\n          lib$rsvp$promise$$needsNew();\n        }\n\n        lib$rsvp$$internal$$initializePromise(promise, resolver);\n      }\n    }\n\n    var lib$rsvp$promise$$default = lib$rsvp$promise$$Promise;\n\n    // deprecated\n    lib$rsvp$promise$$Promise.cast = lib$rsvp$promise$resolve$$default;\n    lib$rsvp$promise$$Promise.all = lib$rsvp$promise$all$$default;\n    lib$rsvp$promise$$Promise.race = lib$rsvp$promise$race$$default;\n    lib$rsvp$promise$$Promise.resolve = lib$rsvp$promise$resolve$$default;\n    lib$rsvp$promise$$Promise.reject = lib$rsvp$promise$reject$$default;\n\n    lib$rsvp$promise$$Promise.prototype = {\n      constructor: lib$rsvp$promise$$Promise,\n\n      _guidKey: lib$rsvp$promise$$guidKey,\n\n      _onError: function (reason) {\n        var promise = this;\n        lib$rsvp$config$$config.after(function() {\n          if (promise._onError) {\n            lib$rsvp$config$$config['trigger']('error', reason);\n          }\n        });\n      },\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfillment\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection, label) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$rsvp$$internal$$FULFILLED && !onFulfillment || state === lib$rsvp$$internal$$REJECTED && !onRejection) {\n          if (lib$rsvp$config$$config.instrument) {\n            lib$rsvp$instrument$$default('chained', parent, parent);\n          }\n          return parent;\n        }\n\n        parent._onError = null;\n\n        var child = new parent.constructor(lib$rsvp$$internal$$noop, label);\n        var result = parent._result;\n\n        if (lib$rsvp$config$$config.instrument) {\n          lib$rsvp$instrument$$default('chained', parent, child);\n        }\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$rsvp$config$$config.async(function(){\n            lib$rsvp$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$rsvp$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection, label) {\n        return this.then(undefined, onRejection, label);\n      },\n\n    /**\n      `finally` will be invoked regardless of the promise's fate just as native\n      try/catch/finally behaves\n\n      Synchronous example:\n\n      ```js\n      findAuthor() {\n        if (Math.random() > 0.5) {\n          throw new Error();\n        }\n        return new Author();\n      }\n\n      try {\n        return findAuthor(); // succeed or fail\n      } catch(error) {\n        return findOtherAuther();\n      } finally {\n        // always runs\n        // doesn't affect the return value\n      }\n      ```\n\n      Asynchronous example:\n\n      ```js\n      findAuthor().catch(function(reason){\n        return findOtherAuther();\n      }).finally(function(){\n        // author was either found, or not\n      });\n      ```\n\n      @method finally\n      @param {Function} callback\n      @param {String} label optional string for labeling the promise.\n      Useful for tooling.\n      @return {Promise}\n    */\n      'finally': function(callback, label) {\n        var promise = this;\n        var constructor = promise.constructor;\n\n        return promise.then(function(value) {\n          return constructor.resolve(callback()).then(function(){\n            return value;\n          });\n        }, function(reason) {\n          return constructor.resolve(callback()).then(function(){\n            throw reason;\n          });\n        }, label);\n      }\n    };\n\n    function lib$rsvp$all$settled$$AllSettled(Constructor, entries, label) {\n      this._superConstructor(Constructor, entries, false /* don't abort on reject */, label);\n    }\n\n    lib$rsvp$all$settled$$AllSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n    lib$rsvp$all$settled$$AllSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$all$settled$$AllSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n    lib$rsvp$all$settled$$AllSettled.prototype._validationError = function() {\n      return new Error('allSettled must be called with an array');\n    };\n\n    function lib$rsvp$all$settled$$allSettled(entries, label) {\n      return new lib$rsvp$all$settled$$AllSettled(lib$rsvp$promise$$default, entries, label).promise;\n    }\n    var lib$rsvp$all$settled$$default = lib$rsvp$all$settled$$allSettled;\n    function lib$rsvp$all$$all(array, label) {\n      return lib$rsvp$promise$$default.all(array, label);\n    }\n    var lib$rsvp$all$$default = lib$rsvp$all$$all;\n    var lib$rsvp$asap$$len = 0;\n    var lib$rsvp$asap$$toString = {}.toString;\n    var lib$rsvp$asap$$vertxNext;\n    function lib$rsvp$asap$$asap(callback, arg) {\n      lib$rsvp$asap$$queue[lib$rsvp$asap$$len] = callback;\n      lib$rsvp$asap$$queue[lib$rsvp$asap$$len + 1] = arg;\n      lib$rsvp$asap$$len += 2;\n      if (lib$rsvp$asap$$len === 2) {\n        // If len is 1, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        lib$rsvp$asap$$scheduleFlush();\n      }\n    }\n\n    var lib$rsvp$asap$$default = lib$rsvp$asap$$asap;\n\n    var lib$rsvp$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$rsvp$asap$$browserGlobal = lib$rsvp$asap$$browserWindow || {};\n    var lib$rsvp$asap$$BrowserMutationObserver = lib$rsvp$asap$$browserGlobal.MutationObserver || lib$rsvp$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$rsvp$asap$$isNode = typeof self === 'undefined' &&\n      typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$rsvp$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$rsvp$asap$$useNextTick() {\n      var nextTick = process.nextTick;\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // setImmediate should be used instead instead\n      var version = process.versions.node.match(/^(?:(\\d+)\\.)?(?:(\\d+)\\.)?(\\*|\\d+)$/);\n      if (Array.isArray(version) && version[1] === '0' && version[2] === '10') {\n        nextTick = setImmediate;\n      }\n      return function() {\n        nextTick(lib$rsvp$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$rsvp$asap$$useVertxTimer() {\n      return function() {\n        lib$rsvp$asap$$vertxNext(lib$rsvp$asap$$flush);\n      };\n    }\n\n    function lib$rsvp$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$rsvp$asap$$BrowserMutationObserver(lib$rsvp$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$rsvp$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$rsvp$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$rsvp$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$rsvp$asap$$flush, 1);\n      };\n    }\n\n    var lib$rsvp$asap$$queue = new Array(1000);\n    function lib$rsvp$asap$$flush() {\n      for (var i = 0; i < lib$rsvp$asap$$len; i+=2) {\n        var callback = lib$rsvp$asap$$queue[i];\n        var arg = lib$rsvp$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$rsvp$asap$$queue[i] = undefined;\n        lib$rsvp$asap$$queue[i+1] = undefined;\n      }\n\n      lib$rsvp$asap$$len = 0;\n    }\n\n    function lib$rsvp$asap$$attemptVertex() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$rsvp$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$rsvp$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$rsvp$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$rsvp$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$rsvp$asap$$isNode) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useNextTick();\n    } else if (lib$rsvp$asap$$BrowserMutationObserver) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMutationObserver();\n    } else if (lib$rsvp$asap$$isWorker) {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useMessageChannel();\n    } else if (lib$rsvp$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$attemptVertex();\n    } else {\n      lib$rsvp$asap$$scheduleFlush = lib$rsvp$asap$$useSetTimeout();\n    }\n    function lib$rsvp$defer$$defer(label) {\n      var deferred = {};\n\n      deferred['promise'] = new lib$rsvp$promise$$default(function(resolve, reject) {\n        deferred['resolve'] = resolve;\n        deferred['reject'] = reject;\n      }, label);\n\n      return deferred;\n    }\n    var lib$rsvp$defer$$default = lib$rsvp$defer$$defer;\n    function lib$rsvp$filter$$filter(promises, filterFn, label) {\n      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!lib$rsvp$utils$$isFunction(filterFn)) {\n          throw new TypeError(\"You must pass a function as filter's second argument.\");\n        }\n\n        var length = values.length;\n        var filtered = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          filtered[i] = filterFn(values[i]);\n        }\n\n        return lib$rsvp$promise$$default.all(filtered, label).then(function(filtered) {\n          var results = new Array(length);\n          var newLength = 0;\n\n          for (var i = 0; i < length; i++) {\n            if (filtered[i]) {\n              results[newLength] = values[i];\n              newLength++;\n            }\n          }\n\n          results.length = newLength;\n\n          return results;\n        });\n      });\n    }\n    var lib$rsvp$filter$$default = lib$rsvp$filter$$filter;\n\n    function lib$rsvp$promise$hash$$PromiseHash(Constructor, object, label) {\n      this._superConstructor(Constructor, object, true, label);\n    }\n\n    var lib$rsvp$promise$hash$$default = lib$rsvp$promise$hash$$PromiseHash;\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype = lib$rsvp$utils$$o_create(lib$rsvp$enumerator$$default.prototype);\n    lib$rsvp$promise$hash$$PromiseHash.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$promise$hash$$PromiseHash.prototype._init = function() {\n      this._result = {};\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._validateInput = function(input) {\n      return input && typeof input === 'object';\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._validationError = function() {\n      return new Error('Promise.hash must be called with an object');\n    };\n\n    lib$rsvp$promise$hash$$PromiseHash.prototype._enumerate = function() {\n      var enumerator = this;\n      var promise    = enumerator.promise;\n      var input      = enumerator._input;\n      var results    = [];\n\n      for (var key in input) {\n        if (promise._state === lib$rsvp$$internal$$PENDING && Object.prototype.hasOwnProperty.call(input, key)) {\n          results.push({\n            position: key,\n            entry: input[key]\n          });\n        }\n      }\n\n      var length = results.length;\n      enumerator._remaining = length;\n      var result;\n\n      for (var i = 0; promise._state === lib$rsvp$$internal$$PENDING && i < length; i++) {\n        result = results[i];\n        enumerator._eachEntry(result.entry, result.position);\n      }\n    };\n\n    function lib$rsvp$hash$settled$$HashSettled(Constructor, object, label) {\n      this._superConstructor(Constructor, object, false, label);\n    }\n\n    lib$rsvp$hash$settled$$HashSettled.prototype = lib$rsvp$utils$$o_create(lib$rsvp$promise$hash$$default.prototype);\n    lib$rsvp$hash$settled$$HashSettled.prototype._superConstructor = lib$rsvp$enumerator$$default;\n    lib$rsvp$hash$settled$$HashSettled.prototype._makeResult = lib$rsvp$enumerator$$makeSettledResult;\n\n    lib$rsvp$hash$settled$$HashSettled.prototype._validationError = function() {\n      return new Error('hashSettled must be called with an object');\n    };\n\n    function lib$rsvp$hash$settled$$hashSettled(object, label) {\n      return new lib$rsvp$hash$settled$$HashSettled(lib$rsvp$promise$$default, object, label).promise;\n    }\n    var lib$rsvp$hash$settled$$default = lib$rsvp$hash$settled$$hashSettled;\n    function lib$rsvp$hash$$hash(object, label) {\n      return new lib$rsvp$promise$hash$$default(lib$rsvp$promise$$default, object, label).promise;\n    }\n    var lib$rsvp$hash$$default = lib$rsvp$hash$$hash;\n    function lib$rsvp$map$$map(promises, mapFn, label) {\n      return lib$rsvp$promise$$default.all(promises, label).then(function(values) {\n        if (!lib$rsvp$utils$$isFunction(mapFn)) {\n          throw new TypeError(\"You must pass a function as map's second argument.\");\n        }\n\n        var length = values.length;\n        var results = new Array(length);\n\n        for (var i = 0; i < length; i++) {\n          results[i] = mapFn(values[i]);\n        }\n\n        return lib$rsvp$promise$$default.all(results, label);\n      });\n    }\n    var lib$rsvp$map$$default = lib$rsvp$map$$map;\n\n    function lib$rsvp$node$$Result() {\n      this.value = undefined;\n    }\n\n    var lib$rsvp$node$$ERROR = new lib$rsvp$node$$Result();\n    var lib$rsvp$node$$GET_THEN_ERROR = new lib$rsvp$node$$Result();\n\n    function lib$rsvp$node$$getThen(obj) {\n      try {\n       return obj.then;\n      } catch(error) {\n        lib$rsvp$node$$ERROR.value= error;\n        return lib$rsvp$node$$ERROR;\n      }\n    }\n\n\n    function lib$rsvp$node$$tryApply(f, s, a) {\n      try {\n        f.apply(s, a);\n      } catch(error) {\n        lib$rsvp$node$$ERROR.value = error;\n        return lib$rsvp$node$$ERROR;\n      }\n    }\n\n    function lib$rsvp$node$$makeObject(_, argumentNames) {\n      var obj = {};\n      var name;\n      var i;\n      var length = _.length;\n      var args = new Array(length);\n\n      for (var x = 0; x < length; x++) {\n        args[x] = _[x];\n      }\n\n      for (i = 0; i < argumentNames.length; i++) {\n        name = argumentNames[i];\n        obj[name] = args[i + 1];\n      }\n\n      return obj;\n    }\n\n    function lib$rsvp$node$$arrayResult(_) {\n      var length = _.length;\n      var args = new Array(length - 1);\n\n      for (var i = 1; i < length; i++) {\n        args[i - 1] = _[i];\n      }\n\n      return args;\n    }\n\n    function lib$rsvp$node$$wrapThenable(then, promise) {\n      return {\n        then: function(onFulFillment, onRejection) {\n          return then.call(promise, onFulFillment, onRejection);\n        }\n      };\n    }\n\n    function lib$rsvp$node$$denodeify(nodeFunc, options) {\n      var fn = function() {\n        var self = this;\n        var l = arguments.length;\n        var args = new Array(l + 1);\n        var arg;\n        var promiseInput = false;\n\n        for (var i = 0; i < l; ++i) {\n          arg = arguments[i];\n\n          if (!promiseInput) {\n            // TODO: clean this up\n            promiseInput = lib$rsvp$node$$needsPromiseInput(arg);\n            if (promiseInput === lib$rsvp$node$$GET_THEN_ERROR) {\n              var p = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n              lib$rsvp$$internal$$reject(p, lib$rsvp$node$$GET_THEN_ERROR.value);\n              return p;\n            } else if (promiseInput && promiseInput !== true) {\n              arg = lib$rsvp$node$$wrapThenable(promiseInput, arg);\n            }\n          }\n          args[i] = arg;\n        }\n\n        var promise = new lib$rsvp$promise$$default(lib$rsvp$$internal$$noop);\n\n        args[l] = function(err, val) {\n          if (err)\n            lib$rsvp$$internal$$reject(promise, err);\n          else if (options === undefined)\n            lib$rsvp$$internal$$resolve(promise, val);\n          else if (options === true)\n            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$arrayResult(arguments));\n          else if (lib$rsvp$utils$$isArray(options))\n            lib$rsvp$$internal$$resolve(promise, lib$rsvp$node$$makeObject(arguments, options));\n          else\n            lib$rsvp$$internal$$resolve(promise, val);\n        };\n\n        if (promiseInput) {\n          return lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self);\n        } else {\n          return lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self);\n        }\n      };\n\n      fn.__proto__ = nodeFunc;\n\n      return fn;\n    }\n\n    var lib$rsvp$node$$default = lib$rsvp$node$$denodeify;\n\n    function lib$rsvp$node$$handleValueInput(promise, args, nodeFunc, self) {\n      var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n      if (result === lib$rsvp$node$$ERROR) {\n        lib$rsvp$$internal$$reject(promise, result.value);\n      }\n      return promise;\n    }\n\n    function lib$rsvp$node$$handlePromiseInput(promise, args, nodeFunc, self){\n      return lib$rsvp$promise$$default.all(args).then(function(args){\n        var result = lib$rsvp$node$$tryApply(nodeFunc, self, args);\n        if (result === lib$rsvp$node$$ERROR) {\n          lib$rsvp$$internal$$reject(promise, result.value);\n        }\n        return promise;\n      });\n    }\n\n    function lib$rsvp$node$$needsPromiseInput(arg) {\n      if (arg && typeof arg === 'object') {\n        if (arg.constructor === lib$rsvp$promise$$default) {\n          return true;\n        } else {\n          return lib$rsvp$node$$getThen(arg);\n        }\n      } else {\n        return false;\n      }\n    }\n    var lib$rsvp$platform$$platform;\n\n    /* global self */\n    if (typeof self === 'object') {\n      lib$rsvp$platform$$platform = self;\n\n    /* global global */\n    } else if (typeof global === 'object') {\n      lib$rsvp$platform$$platform = global;\n    } else {\n      throw new Error('no global: `self` or `global` found');\n    }\n\n    var lib$rsvp$platform$$default = lib$rsvp$platform$$platform;\n    function lib$rsvp$race$$race(array, label) {\n      return lib$rsvp$promise$$default.race(array, label);\n    }\n    var lib$rsvp$race$$default = lib$rsvp$race$$race;\n    function lib$rsvp$reject$$reject(reason, label) {\n      return lib$rsvp$promise$$default.reject(reason, label);\n    }\n    var lib$rsvp$reject$$default = lib$rsvp$reject$$reject;\n    function lib$rsvp$resolve$$resolve(value, label) {\n      return lib$rsvp$promise$$default.resolve(value, label);\n    }\n    var lib$rsvp$resolve$$default = lib$rsvp$resolve$$resolve;\n    function lib$rsvp$rethrow$$rethrow(reason) {\n      setTimeout(function() {\n        throw reason;\n      });\n      throw reason;\n    }\n    var lib$rsvp$rethrow$$default = lib$rsvp$rethrow$$rethrow;\n\n    // defaults\n    lib$rsvp$config$$config.async = lib$rsvp$asap$$default;\n    lib$rsvp$config$$config.after = function(cb) {\n      setTimeout(cb, 0);\n    };\n    var lib$rsvp$$cast = lib$rsvp$resolve$$default;\n    function lib$rsvp$$async(callback, arg) {\n      lib$rsvp$config$$config.async(callback, arg);\n    }\n\n    function lib$rsvp$$on() {\n      lib$rsvp$config$$config['on'].apply(lib$rsvp$config$$config, arguments);\n    }\n\n    function lib$rsvp$$off() {\n      lib$rsvp$config$$config['off'].apply(lib$rsvp$config$$config, arguments);\n    }\n\n    // Set up instrumentation through `window.__PROMISE_INTRUMENTATION__`\n    if (typeof window !== 'undefined' && typeof window['__PROMISE_INSTRUMENTATION__'] === 'object') {\n      var lib$rsvp$$callbacks = window['__PROMISE_INSTRUMENTATION__'];\n      lib$rsvp$config$$configure('instrument', true);\n      for (var lib$rsvp$$eventName in lib$rsvp$$callbacks) {\n        if (lib$rsvp$$callbacks.hasOwnProperty(lib$rsvp$$eventName)) {\n          lib$rsvp$$on(lib$rsvp$$eventName, lib$rsvp$$callbacks[lib$rsvp$$eventName]);\n        }\n      }\n    }\n\n    var lib$rsvp$umd$$RSVP = {\n      'race': lib$rsvp$race$$default,\n      'Promise': lib$rsvp$promise$$default,\n      'allSettled': lib$rsvp$all$settled$$default,\n      'hash': lib$rsvp$hash$$default,\n      'hashSettled': lib$rsvp$hash$settled$$default,\n      'denodeify': lib$rsvp$node$$default,\n      'on': lib$rsvp$$on,\n      'off': lib$rsvp$$off,\n      'map': lib$rsvp$map$$default,\n      'filter': lib$rsvp$filter$$default,\n      'resolve': lib$rsvp$resolve$$default,\n      'reject': lib$rsvp$reject$$default,\n      'all': lib$rsvp$all$$default,\n      'rethrow': lib$rsvp$rethrow$$default,\n      'defer': lib$rsvp$defer$$default,\n      'EventTarget': lib$rsvp$events$$default,\n      'configure': lib$rsvp$config$$configure,\n      'async': lib$rsvp$$async\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$rsvp$umd$$RSVP; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$rsvp$umd$$RSVP;\n    } else if (typeof lib$rsvp$platform$$default !== 'undefined') {\n      lib$rsvp$platform$$default['RSVP'] = lib$rsvp$umd$$RSVP;\n    }\n}).call(this);\n\n"]},"metadata":{},"sourceType":"script"}