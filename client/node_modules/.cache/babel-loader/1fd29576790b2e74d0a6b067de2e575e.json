{"ast":null,"code":"'use strict'; // based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\n\nvar fs = require('fs');\n\nvar readUInt = require('../readUInt');\n\nfunction isTIFF(buffer) {\n  var hex4 = buffer.toString('hex', 0, 4);\n  return '49492a00' === hex4 || '4d4d002a' === hex4;\n} // Read IFD (image-file-directory) into a buffer\n\n\nfunction readIFD(buffer, filepath, isBigEndian) {\n  var ifdOffset = readUInt(buffer, 32, 4, isBigEndian); // read only till the end of the file\n\n  var bufferSize = 1024;\n  var fileSize = fs.statSync(filepath).size;\n\n  if (ifdOffset + bufferSize > fileSize) {\n    bufferSize = fileSize - ifdOffset - 10;\n  } // populate the buffer\n\n\n  var endBuffer = new Buffer(bufferSize);\n  var descriptor = fs.openSync(filepath, 'r');\n  fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset); // var ifdLength = readUInt(endBuffer, 16, 0, isBigEndian);\n\n  var ifdBuffer = endBuffer.slice(2); //, 2 + 12 * ifdLength);\n\n  return ifdBuffer;\n} // TIFF values seem to be messed up on Big-Endian, this helps\n\n\nfunction readValue(buffer, isBigEndian) {\n  var low = readUInt(buffer, 16, 8, isBigEndian);\n  var high = readUInt(buffer, 16, 10, isBigEndian);\n  return (high << 16) + low;\n} // move to the next tag\n\n\nfunction nextTag(buffer) {\n  if (buffer.length > 24) {\n    return buffer.slice(12);\n  }\n} // Extract IFD tags from TIFF metadata\n\n\nfunction extractTags(buffer, isBigEndian) {\n  var tags = {};\n  var code, type, length;\n\n  while (buffer && buffer.length) {\n    code = readUInt(buffer, 16, 0, isBigEndian);\n    type = readUInt(buffer, 16, 2, isBigEndian);\n    length = readUInt(buffer, 32, 4, isBigEndian); // 0 means end of IFD\n\n    if (code === 0) {\n      break;\n    } else {\n      // 256 is width, 257 is height\n      // if (code === 256 || code === 257) {\n      if (length === 1 && type === 3) {\n        tags[code] = readValue(buffer, isBigEndian);\n      } // move to the next tag\n\n\n      buffer = nextTag(buffer);\n    }\n  }\n\n  return tags;\n} // Test if the TIFF is Big Endian or Little Endian\n\n\nfunction determineEndianness(buffer) {\n  var signature = buffer.toString('ascii', 0, 2);\n\n  if ('II' === signature) {\n    return 'LE';\n  } else if ('MM' === signature) {\n    return 'BE';\n  }\n}\n\nfunction calculate(buffer, filepath) {\n  if (!filepath) {\n    throw new TypeError('Tiff doesn\\'t support buffer');\n  } // Determine BE/LE\n\n\n  var isBigEndian = determineEndianness(buffer) === 'BE'; // read the IFD\n\n  var ifdBuffer = readIFD(buffer, filepath, isBigEndian); // extract the tags from the IFD\n\n  var tags = extractTags(ifdBuffer, isBigEndian);\n  var width = tags[256];\n  var height = tags[257];\n\n  if (!width || !height) {\n    throw new TypeError('Invalid Tiff, missing tags');\n  }\n\n  return {\n    'width': width,\n    'height': height\n  };\n}\n\nmodule.exports = {\n  'detect': isTIFF,\n  'calculate': calculate\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/image-size/lib/types/tiff.js"],"names":["fs","require","readUInt","isTIFF","buffer","hex4","toString","readIFD","filepath","isBigEndian","ifdOffset","bufferSize","fileSize","statSync","size","endBuffer","Buffer","descriptor","openSync","readSync","ifdBuffer","slice","readValue","low","high","nextTag","length","extractTags","tags","code","type","determineEndianness","signature","calculate","TypeError","width","height","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n// based on http://www.compix.com/fileformattif.htm\n// TO-DO: support big-endian as well\n\nvar fs = require('fs');\nvar readUInt = require('../readUInt');\n\nfunction isTIFF (buffer) {\n  var hex4 = buffer.toString('hex', 0, 4);\n  return ('49492a00' === hex4 || '4d4d002a' === hex4);\n}\n\n// Read IFD (image-file-directory) into a buffer\nfunction readIFD (buffer, filepath, isBigEndian) {\n\n  var ifdOffset = readUInt(buffer, 32, 4, isBigEndian);\n\n  // read only till the end of the file\n  var bufferSize = 1024;\n  var fileSize = fs.statSync(filepath).size;\n  if (ifdOffset + bufferSize > fileSize) {\n    bufferSize = fileSize - ifdOffset - 10;\n  }\n\n  // populate the buffer\n  var endBuffer = new Buffer(bufferSize);\n  var descriptor = fs.openSync(filepath, 'r');\n  fs.readSync(descriptor, endBuffer, 0, bufferSize, ifdOffset);\n\n  // var ifdLength = readUInt(endBuffer, 16, 0, isBigEndian);\n  var ifdBuffer = endBuffer.slice(2); //, 2 + 12 * ifdLength);\n  return ifdBuffer;\n}\n\n// TIFF values seem to be messed up on Big-Endian, this helps\nfunction readValue (buffer, isBigEndian) {\n  var low = readUInt(buffer, 16, 8, isBigEndian);\n  var high = readUInt(buffer, 16, 10, isBigEndian);\n  return (high << 16) + low;\n}\n\n// move to the next tag\nfunction nextTag (buffer) {\n  if (buffer.length > 24) {\n    return buffer.slice(12);\n  }\n}\n\n// Extract IFD tags from TIFF metadata\nfunction extractTags (buffer, isBigEndian) {\n  var tags = {};\n  var code, type, length;\n\n  while (buffer && buffer.length) {\n    code = readUInt(buffer, 16, 0, isBigEndian);\n    type = readUInt(buffer, 16, 2, isBigEndian);\n    length = readUInt(buffer, 32, 4, isBigEndian);\n\n    // 0 means end of IFD\n    if (code === 0) {\n      break;\n    } else {\n      // 256 is width, 257 is height\n      // if (code === 256 || code === 257) {\n      if (length === 1 && type === 3) {\n        tags[code] = readValue(buffer, isBigEndian);\n      }\n\n      // move to the next tag\n      buffer = nextTag(buffer);\n    }\n  }\n  return tags;\n}\n\n// Test if the TIFF is Big Endian or Little Endian\nfunction determineEndianness (buffer) {\n  var signature = buffer.toString('ascii', 0, 2);\n  if ('II' === signature) {\n    return 'LE';\n  } else if ('MM' === signature) {\n    return 'BE';\n  }\n}\n\nfunction calculate (buffer, filepath) {\n\n  if (!filepath) {\n    throw new TypeError('Tiff doesn\\'t support buffer');\n  }\n\n  // Determine BE/LE\n  var isBigEndian = determineEndianness(buffer) === 'BE';\n\n  // read the IFD\n  var ifdBuffer = readIFD(buffer, filepath, isBigEndian);\n\n  // extract the tags from the IFD\n  var tags = extractTags(ifdBuffer, isBigEndian);\n\n  var width = tags[256];\n  var height = tags[257];\n\n  if (!width || !height) {\n    throw new TypeError('Invalid Tiff, missing tags');\n  }\n\n  return {\n    'width': width,\n    'height': height\n  };\n}\n\nmodule.exports = {\n  'detect': isTIFF,\n  'calculate': calculate\n};\n"]},"metadata":{},"sourceType":"script"}