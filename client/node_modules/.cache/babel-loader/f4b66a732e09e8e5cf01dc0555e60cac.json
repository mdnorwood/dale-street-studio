{"ast":null,"code":"/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n  blocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n  marks each block that fits with a .fit attribute pointing to a\n  node with .x and .y coordinates\n\nExample:\n-------\n\n  var blocks = [\n    { w: 100, h: 100 },\n    { w: 100, h: 100 },\n    { w:  80, h:  80 },\n    { w:  80, h:  80 },\n    etc\n    etc\n  ];\n\n  var packer = new GrowingPacker();\n  packer.fit(blocks);\n\n  for(var n = 0 ; n < blocks.length ; n++) {\n    var block = blocks[n];\n    if (block.fit) {\n      Draw(block.fit.x, block.fit.y, block.w, block.h);\n    }\n  }\n\n\n******************************************************************************/\n-function (exports) {\n  var GrowingPacker = exports.GrowingPacker = function () {};\n\n  GrowingPacker.prototype = {\n    fit: function (blocks) {\n      var n,\n          node,\n          block,\n          len = blocks.length;\n      var w = len > 0 ? blocks[0].w : 0;\n      var h = len > 0 ? blocks[0].h : 0;\n      this.root = {\n        x: 0,\n        y: 0,\n        w: w,\n        h: h\n      };\n\n      for (n = 0; n < len; n++) {\n        block = blocks[n];\n        if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);else block.fit = this.growNode(block.w, block.h);\n      }\n    },\n    findNode: function (root, w, h) {\n      if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;\n    },\n    splitNode: function (node, w, h) {\n      node.used = true;\n      node.down = {\n        x: node.x,\n        y: node.y + h,\n        w: node.w,\n        h: node.h - h\n      };\n      node.right = {\n        x: node.x + w,\n        y: node.y,\n        w: node.w - w,\n        h: h\n      };\n      return node;\n    },\n    growNode: function (w, h) {\n      var canGrowDown = w <= this.root.w;\n      var canGrowRight = h <= this.root.h;\n      var shouldGrowRight = canGrowRight && this.root.h >= this.root.w + w; // attempt to keep square-ish by growing right when height is much greater than width\n\n      var shouldGrowDown = canGrowDown && this.root.w >= this.root.h + h; // attempt to keep square-ish by growing down  when width  is much greater than height\n\n      if (shouldGrowRight) return this.growRight(w, h);else if (shouldGrowDown) return this.growDown(w, h);else if (canGrowRight) return this.growRight(w, h);else if (canGrowDown) return this.growDown(w, h);else return null; // need to ensure sensible root starting size to avoid this happening\n    },\n    growRight: function (w, h) {\n      this.root = {\n        used: true,\n        x: 0,\n        y: 0,\n        w: this.root.w + w,\n        h: this.root.h,\n        down: this.root,\n        right: {\n          x: this.root.w,\n          y: 0,\n          w: w,\n          h: this.root.h\n        }\n      };\n      if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;\n    },\n    growDown: function (w, h) {\n      this.root = {\n        used: true,\n        x: 0,\n        y: 0,\n        w: this.root.w,\n        h: this.root.h + h,\n        down: {\n          x: 0,\n          y: this.root.h,\n          w: this.root.w,\n          h: h\n        },\n        right: this.root\n      };\n      if (node = this.findNode(this.root, w, h)) return this.splitNode(node, w, h);else return null;\n    }\n  };\n}(typeof window !== 'undefined' ? window : module.exports);","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/binpacking/js/packer.growing.js"],"names":["exports","GrowingPacker","prototype","fit","blocks","n","node","block","len","length","w","h","root","x","y","findNode","splitNode","growNode","used","right","down","canGrowDown","canGrowRight","shouldGrowRight","shouldGrowDown","growRight","growDown","window","module"],"mappings":"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","sourcesContent":["/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n  blocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n  marks each block that fits with a .fit attribute pointing to a\n  node with .x and .y coordinates\n\nExample:\n-------\n\n  var blocks = [\n    { w: 100, h: 100 },\n    { w: 100, h: 100 },\n    { w:  80, h:  80 },\n    { w:  80, h:  80 },\n    etc\n    etc\n  ];\n\n  var packer = new GrowingPacker();\n  packer.fit(blocks);\n\n  for(var n = 0 ; n < blocks.length ; n++) {\n    var block = blocks[n];\n    if (block.fit) {\n      Draw(block.fit.x, block.fit.y, block.w, block.h);\n    }\n  }\n\n\n******************************************************************************/\n-function (exports) {\n\nvar GrowingPacker = exports.GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n  fit: function(blocks) {\n    var n, node, block, len = blocks.length;\n    var w = len > 0 ? blocks[0].w : 0;\n    var h = len > 0 ? blocks[0].h : 0;\n    this.root = { x: 0, y: 0, w: w, h: h };\n    for (n = 0; n < len ; n++) {\n      block = blocks[n];\n      if (node = this.findNode(this.root, block.w, block.h))\n        block.fit = this.splitNode(node, block.w, block.h);\n      else\n        block.fit = this.growNode(block.w, block.h);\n    }\n  },\n\n  findNode: function(root, w, h) {\n    if (root.used)\n      return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);\n    else if ((w <= root.w) && (h <= root.h))\n      return root;\n    else\n      return null;\n  },\n\n  splitNode: function(node, w, h) {\n    node.used = true;\n    node.down  = { x: node.x,     y: node.y + h, w: node.w,     h: node.h - h };\n    node.right = { x: node.x + w, y: node.y,     w: node.w - w, h: h          };\n    return node;\n  },\n\n  growNode: function(w, h) {\n    var canGrowDown  = (w <= this.root.w);\n    var canGrowRight = (h <= this.root.h);\n\n    var shouldGrowRight = canGrowRight && (this.root.h >= (this.root.w + w)); // attempt to keep square-ish by growing right when height is much greater than width\n    var shouldGrowDown  = canGrowDown  && (this.root.w >= (this.root.h + h)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n    if (shouldGrowRight)\n      return this.growRight(w, h);\n    else if (shouldGrowDown)\n      return this.growDown(w, h);\n    else if (canGrowRight)\n     return this.growRight(w, h);\n    else if (canGrowDown)\n      return this.growDown(w, h);\n    else\n      return null; // need to ensure sensible root starting size to avoid this happening\n  },\n\n  growRight: function(w, h) {\n    this.root = {\n      used: true,\n      x: 0,\n      y: 0,\n      w: this.root.w + w,\n      h: this.root.h,\n      down: this.root,\n      right: { x: this.root.w, y: 0, w: w, h: this.root.h }\n    };\n    if (node = this.findNode(this.root, w, h))\n      return this.splitNode(node, w, h);\n    else\n      return null;\n  },\n\n  growDown: function(w, h) {\n    this.root = {\n      used: true,\n      x: 0,\n      y: 0,\n      w: this.root.w,\n      h: this.root.h + h,\n      down:  { x: 0, y: this.root.h, w: this.root.w, h: h },\n      right: this.root\n    };\n    if (node = this.findNode(this.root, w, h))\n      return this.splitNode(node, w, h);\n    else\n      return null;\n  }\n\n}\n\n}(typeof window !== 'undefined' ? window : module.exports);"]},"metadata":{},"sourceType":"script"}