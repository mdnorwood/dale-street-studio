{"ast":null,"code":"\"use strict\";\n\nlet constants = require(\"./constants\");\n\nlet CrcStream = require(\"./crc\");\n\nlet bitPacker = require(\"./bitpacker\");\n\nlet filter = require(\"./filter-pack\");\n\nlet zlib = require(\"zlib\");\n\nlet Packer = module.exports = function (options) {\n  this._options = options;\n  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;\n  options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;\n  options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;\n  options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;\n  options.deflateFactory = options.deflateFactory || zlib.createDeflate;\n  options.bitDepth = options.bitDepth || 8; // This is outputColorType\n\n  options.colorType = typeof options.colorType === \"number\" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;\n  options.inputColorType = typeof options.inputColorType === \"number\" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;\n\n  if ([constants.COLORTYPE_GRAYSCALE, constants.COLORTYPE_COLOR, constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) === -1) {\n    throw new Error(\"option color type:\" + options.colorType + \" is not supported at present\");\n  }\n\n  if ([constants.COLORTYPE_GRAYSCALE, constants.COLORTYPE_COLOR, constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.inputColorType) === -1) {\n    throw new Error(\"option input color type:\" + options.inputColorType + \" is not supported at present\");\n  }\n\n  if (options.bitDepth !== 8 && options.bitDepth !== 16) {\n    throw new Error(\"option bit depth:\" + options.bitDepth + \" is not supported at present\");\n  }\n};\n\nPacker.prototype.getDeflateOptions = function () {\n  return {\n    chunkSize: this._options.deflateChunkSize,\n    level: this._options.deflateLevel,\n    strategy: this._options.deflateStrategy\n  };\n};\n\nPacker.prototype.createDeflate = function () {\n  return this._options.deflateFactory(this.getDeflateOptions());\n};\n\nPacker.prototype.filterData = function (data, width, height) {\n  // convert to correct format for filtering (e.g. right bpp and bit depth)\n  let packedData = bitPacker(data, width, height, this._options); // filter pixel data\n\n  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];\n  let filteredData = filter(packedData, width, height, this._options, bpp);\n  return filteredData;\n};\n\nPacker.prototype._packChunk = function (type, data) {\n  let len = data ? data.length : 0;\n  let buf = Buffer.alloc(len + 12);\n  buf.writeUInt32BE(len, 0);\n  buf.writeUInt32BE(type, 4);\n\n  if (data) {\n    data.copy(buf, 8);\n  }\n\n  buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);\n  return buf;\n};\n\nPacker.prototype.packGAMA = function (gamma) {\n  let buf = Buffer.alloc(4);\n  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);\n  return this._packChunk(constants.TYPE_gAMA, buf);\n};\n\nPacker.prototype.packIHDR = function (width, height) {\n  let buf = Buffer.alloc(13);\n  buf.writeUInt32BE(width, 0);\n  buf.writeUInt32BE(height, 4);\n  buf[8] = this._options.bitDepth; // Bit depth\n\n  buf[9] = this._options.colorType; // colorType\n\n  buf[10] = 0; // compression\n\n  buf[11] = 0; // filter\n\n  buf[12] = 0; // interlace\n\n  return this._packChunk(constants.TYPE_IHDR, buf);\n};\n\nPacker.prototype.packIDAT = function (data) {\n  return this._packChunk(constants.TYPE_IDAT, data);\n};\n\nPacker.prototype.packIEND = function () {\n  return this._packChunk(constants.TYPE_IEND, null);\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/pngjs/lib/packer.js"],"names":["constants","require","CrcStream","bitPacker","filter","zlib","Packer","module","exports","options","_options","deflateChunkSize","deflateLevel","deflateStrategy","inputHasAlpha","deflateFactory","createDeflate","bitDepth","colorType","COLORTYPE_COLOR_ALPHA","inputColorType","COLORTYPE_GRAYSCALE","COLORTYPE_COLOR","COLORTYPE_ALPHA","indexOf","Error","prototype","getDeflateOptions","chunkSize","level","strategy","filterData","data","width","height","packedData","bpp","COLORTYPE_TO_BPP_MAP","filteredData","_packChunk","type","len","length","buf","Buffer","alloc","writeUInt32BE","copy","writeInt32BE","crc32","slice","packGAMA","gamma","Math","floor","GAMMA_DIVISION","TYPE_gAMA","packIHDR","TYPE_IHDR","packIDAT","TYPE_IDAT","packIEND","TYPE_IEND"],"mappings":"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","sourcesContent":["\"use strict\";\n\nlet constants = require(\"./constants\");\nlet CrcStream = require(\"./crc\");\nlet bitPacker = require(\"./bitpacker\");\nlet filter = require(\"./filter-pack\");\nlet zlib = require(\"zlib\");\n\nlet Packer = (module.exports = function (options) {\n  this._options = options;\n\n  options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;\n  options.deflateLevel =\n    options.deflateLevel != null ? options.deflateLevel : 9;\n  options.deflateStrategy =\n    options.deflateStrategy != null ? options.deflateStrategy : 3;\n  options.inputHasAlpha =\n    options.inputHasAlpha != null ? options.inputHasAlpha : true;\n  options.deflateFactory = options.deflateFactory || zlib.createDeflate;\n  options.bitDepth = options.bitDepth || 8;\n  // This is outputColorType\n  options.colorType =\n    typeof options.colorType === \"number\"\n      ? options.colorType\n      : constants.COLORTYPE_COLOR_ALPHA;\n  options.inputColorType =\n    typeof options.inputColorType === \"number\"\n      ? options.inputColorType\n      : constants.COLORTYPE_COLOR_ALPHA;\n\n  if (\n    [\n      constants.COLORTYPE_GRAYSCALE,\n      constants.COLORTYPE_COLOR,\n      constants.COLORTYPE_COLOR_ALPHA,\n      constants.COLORTYPE_ALPHA,\n    ].indexOf(options.colorType) === -1\n  ) {\n    throw new Error(\n      \"option color type:\" + options.colorType + \" is not supported at present\"\n    );\n  }\n  if (\n    [\n      constants.COLORTYPE_GRAYSCALE,\n      constants.COLORTYPE_COLOR,\n      constants.COLORTYPE_COLOR_ALPHA,\n      constants.COLORTYPE_ALPHA,\n    ].indexOf(options.inputColorType) === -1\n  ) {\n    throw new Error(\n      \"option input color type:\" +\n        options.inputColorType +\n        \" is not supported at present\"\n    );\n  }\n  if (options.bitDepth !== 8 && options.bitDepth !== 16) {\n    throw new Error(\n      \"option bit depth:\" + options.bitDepth + \" is not supported at present\"\n    );\n  }\n});\n\nPacker.prototype.getDeflateOptions = function () {\n  return {\n    chunkSize: this._options.deflateChunkSize,\n    level: this._options.deflateLevel,\n    strategy: this._options.deflateStrategy,\n  };\n};\n\nPacker.prototype.createDeflate = function () {\n  return this._options.deflateFactory(this.getDeflateOptions());\n};\n\nPacker.prototype.filterData = function (data, width, height) {\n  // convert to correct format for filtering (e.g. right bpp and bit depth)\n  let packedData = bitPacker(data, width, height, this._options);\n\n  // filter pixel data\n  let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];\n  let filteredData = filter(packedData, width, height, this._options, bpp);\n  return filteredData;\n};\n\nPacker.prototype._packChunk = function (type, data) {\n  let len = data ? data.length : 0;\n  let buf = Buffer.alloc(len + 12);\n\n  buf.writeUInt32BE(len, 0);\n  buf.writeUInt32BE(type, 4);\n\n  if (data) {\n    data.copy(buf, 8);\n  }\n\n  buf.writeInt32BE(\n    CrcStream.crc32(buf.slice(4, buf.length - 4)),\n    buf.length - 4\n  );\n  return buf;\n};\n\nPacker.prototype.packGAMA = function (gamma) {\n  let buf = Buffer.alloc(4);\n  buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);\n  return this._packChunk(constants.TYPE_gAMA, buf);\n};\n\nPacker.prototype.packIHDR = function (width, height) {\n  let buf = Buffer.alloc(13);\n  buf.writeUInt32BE(width, 0);\n  buf.writeUInt32BE(height, 4);\n  buf[8] = this._options.bitDepth; // Bit depth\n  buf[9] = this._options.colorType; // colorType\n  buf[10] = 0; // compression\n  buf[11] = 0; // filter\n  buf[12] = 0; // interlace\n\n  return this._packChunk(constants.TYPE_IHDR, buf);\n};\n\nPacker.prototype.packIDAT = function (data) {\n  return this._packChunk(constants.TYPE_IDAT, data);\n};\n\nPacker.prototype.packIEND = function () {\n  return this._packChunk(constants.TYPE_IEND, null);\n};\n"]},"metadata":{},"sourceType":"script"}