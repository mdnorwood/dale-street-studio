{"ast":null,"code":"/******************************************************************************\n\nThis is a very simple binary tree based bin packing algorithm that is initialized\nwith a fixed width and height and will fit each block into the first node where\nit fits and then split that node into 2 parts (down and right) to track the\nremaining whitespace.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n  w:       width of target rectangle\n  h:      height of target rectangle\n  blocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n  marks each block that fits with a .fit attribute pointing to a\n  node with .x and .y coordinates\n\nExample:\n-------\n\n  var blocks = [\n    { w: 100, h: 100 },\n    { w: 100, h: 100 },\n    { w:  80, h:  80 },\n    { w:  80, h:  80 },\n    etc\n    etc\n  ];\n\n  var packer = new Packer(500, 500);\n  packer.fit(blocks);\n\n  for(var n = 0 ; n < blocks.length ; n++) {\n    var block = blocks[n];\n    if (block.fit) {\n      Draw(block.fit.x, block.fit.y, block.w, block.h);\n    }\n  }\n\n\n******************************************************************************/\n-function (exports) {\n  var Packer = exports.Packer = function (w, h) {\n    this.init(w, h);\n  };\n\n  Packer.prototype = {\n    init: function init(w, h) {\n      this.root = {\n        x: 0,\n        y: 0,\n        w: w,\n        h: h\n      };\n    },\n    fit: function fit(blocks) {\n      var n, node, block;\n\n      for (n = 0; n < blocks.length; n++) {\n        block = blocks[n];\n        if (node = this.findNode(this.root, block.w, block.h)) block.fit = this.splitNode(node, block.w, block.h);\n      }\n    },\n    findNode: function findNode(root, w, h) {\n      if (root.used) return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);else if (w <= root.w && h <= root.h) return root;else return null;\n    },\n    splitNode: function splitNode(node, w, h) {\n      node.used = true;\n      node.down = {\n        x: node.x,\n        y: node.y + h,\n        w: node.w,\n        h: node.h - h\n      };\n      node.right = {\n        x: node.x + w,\n        y: node.y,\n        w: node.w - w,\n        h: h\n      };\n      return node;\n    }\n  };\n}(typeof window !== 'undefined' ? window : module.exports);","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/binpacking/js/packer.js"],"names":["exports","Packer","w","h","init","prototype","root","x","y","fit","blocks","n","node","block","length","findNode","splitNode","used","right","down","window","module"],"mappings":"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","sourcesContent":["/******************************************************************************\n\nThis is a very simple binary tree based bin packing algorithm that is initialized\nwith a fixed width and height and will fit each block into the first node where\nit fits and then split that node into 2 parts (down and right) to track the\nremaining whitespace.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n  w:       width of target rectangle\n  h:      height of target rectangle\n  blocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n  marks each block that fits with a .fit attribute pointing to a\n  node with .x and .y coordinates\n\nExample:\n-------\n\n  var blocks = [\n    { w: 100, h: 100 },\n    { w: 100, h: 100 },\n    { w:  80, h:  80 },\n    { w:  80, h:  80 },\n    etc\n    etc\n  ];\n\n  var packer = new Packer(500, 500);\n  packer.fit(blocks);\n\n  for(var n = 0 ; n < blocks.length ; n++) {\n    var block = blocks[n];\n    if (block.fit) {\n      Draw(block.fit.x, block.fit.y, block.w, block.h);\n    }\n  }\n\n\n******************************************************************************/\n\n-function (exports) {\n\n\nvar Packer = exports.Packer = function(w, h) {\n  this.init(w, h);\n};\n\nPacker.prototype = {\n\n  init: function(w, h) {\n    this.root = { x: 0, y: 0, w: w, h: h };\n  },\n\n  fit: function(blocks) {\n    var n, node, block;\n    for (n = 0; n < blocks.length; n++) {\n      block = blocks[n];\n      if (node = this.findNode(this.root, block.w, block.h))\n        block.fit = this.splitNode(node, block.w, block.h);\n    }\n  },\n\n  findNode: function(root, w, h) {\n    if (root.used)\n      return this.findNode(root.right, w, h) || this.findNode(root.down, w, h);\n    else if ((w <= root.w) && (h <= root.h))\n      return root;\n    else\n      return null;\n  },\n\n  splitNode: function(node, w, h) {\n    node.used = true;\n    node.down  = { x: node.x,     y: node.y + h, w: node.w,     h: node.h - h };\n    node.right = { x: node.x + w, y: node.y,     w: node.w - w, h: h          };\n    return node;\n  }\n\n}\n\n}(typeof window !== 'undefined' ? window : module.exports);"]},"metadata":{},"sourceType":"script"}