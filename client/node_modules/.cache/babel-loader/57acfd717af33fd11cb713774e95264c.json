{"ast":null,"code":"\"use strict\";\n\nlet constants = require(\"./constants\");\n\nmodule.exports = function (dataIn, width, height, options) {\n  let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;\n\n  if (options.colorType === options.inputColorType) {\n    let bigEndian = function () {\n      let buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true\n      /* littleEndian */\n      ); // Int16Array uses the platform's endianness.\n\n      return new Int16Array(buffer)[0] !== 256;\n    }(); // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n\n\n    if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {\n      return dataIn;\n    }\n  } // map to a UInt16 array if data is 16bit, fix endianness below\n\n\n  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n  let maxValue = 255;\n  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n\n  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n\n  let outData = Buffer.alloc(width * height * outBpp);\n  let inIndex = 0;\n  let outIndex = 0;\n  let bgColor = options.bgColor || {};\n\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA() {\n    let red;\n    let green;\n    let blue;\n    let alpha = maxValue;\n\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n\n      default:\n        throw new Error(\"input color type:\" + options.inputColorType + \" is not supported at present\");\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);\n        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);\n        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);\n      }\n    }\n\n    return {\n      red: red,\n      green: green,\n      blue: blue,\n      alpha: alpha\n    };\n  }\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n\n          break;\n\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE:\n          {\n            // Convert to grayscale and alpha\n            let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n\n            if (options.bitDepth === 8) {\n              outData[outIndex] = grayscale;\n\n              if (outHasAlpha) {\n                outData[outIndex + 1] = rgba.alpha;\n              }\n            } else {\n              outData.writeUInt16BE(grayscale, outIndex);\n\n              if (outHasAlpha) {\n                outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n              }\n            }\n\n            break;\n          }\n\n        default:\n          throw new Error(\"unrecognised color Type \" + options.colorType);\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/pngjs/lib/bitpacker.js"],"names":["constants","require","module","exports","dataIn","width","height","options","outHasAlpha","COLORTYPE_COLOR_ALPHA","COLORTYPE_ALPHA","indexOf","colorType","inputColorType","bigEndian","buffer","ArrayBuffer","DataView","setInt16","Int16Array","bitDepth","data","Uint16Array","maxValue","inBpp","COLORTYPE_TO_BPP_MAP","inputHasAlpha","outBpp","outData","Buffer","alloc","inIndex","outIndex","bgColor","red","undefined","green","blue","getRGBA","alpha","COLORTYPE_COLOR","COLORTYPE_GRAYSCALE","Error","Math","min","max","round","y","x","rgba","writeUInt16BE","grayscale"],"mappings":"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","sourcesContent":["\"use strict\";\n\nlet constants = require(\"./constants\");\n\nmodule.exports = function (dataIn, width, height, options) {\n  let outHasAlpha =\n    [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(\n      options.colorType\n    ) !== -1;\n  if (options.colorType === options.inputColorType) {\n    let bigEndian = (function () {\n      let buffer = new ArrayBuffer(2);\n      new DataView(buffer).setInt16(0, 256, true /* littleEndian */);\n      // Int16Array uses the platform's endianness.\n      return new Int16Array(buffer)[0] !== 256;\n    })();\n    // If no need to convert to grayscale and alpha is present/absent in both, take a fast route\n    if (options.bitDepth === 8 || (options.bitDepth === 16 && bigEndian)) {\n      return dataIn;\n    }\n  }\n\n  // map to a UInt16 array if data is 16bit, fix endianness below\n  let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);\n\n  let maxValue = 255;\n  let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];\n  if (inBpp === 4 && !options.inputHasAlpha) {\n    inBpp = 3;\n  }\n  let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];\n  if (options.bitDepth === 16) {\n    maxValue = 65535;\n    outBpp *= 2;\n  }\n  let outData = Buffer.alloc(width * height * outBpp);\n\n  let inIndex = 0;\n  let outIndex = 0;\n\n  let bgColor = options.bgColor || {};\n  if (bgColor.red === undefined) {\n    bgColor.red = maxValue;\n  }\n  if (bgColor.green === undefined) {\n    bgColor.green = maxValue;\n  }\n  if (bgColor.blue === undefined) {\n    bgColor.blue = maxValue;\n  }\n\n  function getRGBA() {\n    let red;\n    let green;\n    let blue;\n    let alpha = maxValue;\n    switch (options.inputColorType) {\n      case constants.COLORTYPE_COLOR_ALPHA:\n        alpha = data[inIndex + 3];\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_COLOR:\n        red = data[inIndex];\n        green = data[inIndex + 1];\n        blue = data[inIndex + 2];\n        break;\n      case constants.COLORTYPE_ALPHA:\n        alpha = data[inIndex + 1];\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      case constants.COLORTYPE_GRAYSCALE:\n        red = data[inIndex];\n        green = red;\n        blue = red;\n        break;\n      default:\n        throw new Error(\n          \"input color type:\" +\n            options.inputColorType +\n            \" is not supported at present\"\n        );\n    }\n\n    if (options.inputHasAlpha) {\n      if (!outHasAlpha) {\n        alpha /= maxValue;\n        red = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0),\n          maxValue\n        );\n        green = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0),\n          maxValue\n        );\n        blue = Math.min(\n          Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0),\n          maxValue\n        );\n      }\n    }\n    return { red: red, green: green, blue: blue, alpha: alpha };\n  }\n\n  for (let y = 0; y < height; y++) {\n    for (let x = 0; x < width; x++) {\n      let rgba = getRGBA(data, inIndex);\n\n      switch (options.colorType) {\n        case constants.COLORTYPE_COLOR_ALPHA:\n        case constants.COLORTYPE_COLOR:\n          if (options.bitDepth === 8) {\n            outData[outIndex] = rgba.red;\n            outData[outIndex + 1] = rgba.green;\n            outData[outIndex + 2] = rgba.blue;\n            if (outHasAlpha) {\n              outData[outIndex + 3] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(rgba.red, outIndex);\n            outData.writeUInt16BE(rgba.green, outIndex + 2);\n            outData.writeUInt16BE(rgba.blue, outIndex + 4);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 6);\n            }\n          }\n          break;\n        case constants.COLORTYPE_ALPHA:\n        case constants.COLORTYPE_GRAYSCALE: {\n          // Convert to grayscale and alpha\n          let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;\n          if (options.bitDepth === 8) {\n            outData[outIndex] = grayscale;\n            if (outHasAlpha) {\n              outData[outIndex + 1] = rgba.alpha;\n            }\n          } else {\n            outData.writeUInt16BE(grayscale, outIndex);\n            if (outHasAlpha) {\n              outData.writeUInt16BE(rgba.alpha, outIndex + 2);\n            }\n          }\n          break;\n        }\n        default:\n          throw new Error(\"unrecognised color Type \" + options.colorType);\n      }\n\n      inIndex += inBpp;\n      outIndex += outBpp;\n    }\n  }\n\n  return outData;\n};\n"]},"metadata":{},"sourceType":"script"}