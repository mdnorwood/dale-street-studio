{"ast":null,"code":"\"use strict\";\n\nlet assert = require(\"assert\").ok;\n\nlet zlib = require(\"zlib\");\n\nlet util = require(\"util\");\n\nlet kMaxLength = require(\"buffer\").kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts); // Node 8 --> 9 compatibility check\n\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  } // Caller may invoke .close after a zlib error (which will null _handle).\n\n\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === \"function\") {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  let self = this;\n  let availInBefore = chunk && chunk.length;\n  let availOutBefore = this._chunkSize - this._offset;\n  let leftToInflate = this._maxLength;\n  let inOff = 0;\n  let buffers = [];\n  let nread = 0;\n  let error;\n  this.on(\"error\", function (err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    let have = availOutBefore - availOutAfter;\n    assert(have >= 0, \"have should not go down\");\n\n    if (have > 0) {\n      let out = self._buffer.slice(self._offset, self._offset + have);\n\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, \"zlib binding closed\");\n  let res;\n\n  do {\n    res = this._handle.writeSync(flushFlag, chunk, // in\n    inOff, // in_off\n    availInBefore, // in_len\n    this._buffer, // out\n    this._offset, //out_off\n    availOutBefore); // out_len\n    // Node 8 --> 9 compatibility check\n\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n\n    throw new RangeError(\"Cannot create final Buffer. It would be larger than 0x\" + kMaxLength.toString(16) + \" bytes\");\n  }\n\n  let buf = Buffer.concat(buffers, nread);\n\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === \"string\") {\n    buffer = Buffer.from(buffer);\n  }\n\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError(\"Not a string or buffer\");\n  }\n\n  let flushFlag = engine._finishFlushFlag;\n\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/pngjs/lib/sync-inflate.js"],"names":["assert","require","ok","zlib","util","kMaxLength","Inflate","opts","chunkSize","Z_MIN_CHUNK","call","_offset","undefined","_outOffset","_buffer","_outBuffer","maxLength","_maxLength","createInflate","_close","engine","callback","process","nextTick","_handle","close","prototype","_processChunk","chunk","flushFlag","asyncCb","self","availInBefore","length","availOutBefore","_chunkSize","leftToInflate","inOff","buffers","nread","error","on","err","handleChunk","availInAfter","availOutAfter","_hadError","have","out","slice","push","Buffer","allocUnsafe","res","writeSync","_writeState","RangeError","toString","buf","concat","inherits","zlibBufferSync","buffer","from","TypeError","_finishFlushFlag","Z_FINISH","inflateSync","module","exports"],"mappings":"AAAA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAP,CAAkBC,EAA/B;;AACA,IAAIC,IAAI,GAAGF,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,MAAD,CAAlB;;AAEA,IAAII,UAAU,GAAGJ,OAAO,CAAC,QAAD,CAAP,CAAkBI,UAAnC;;AAEA,SAASC,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAI,EAAE,gBAAgBD,OAAlB,CAAJ,EAAgC;AAC9B,WAAO,IAAIA,OAAJ,CAAYC,IAAZ,CAAP;AACD;;AAED,MAAIA,IAAI,IAAIA,IAAI,CAACC,SAAL,GAAiBL,IAAI,CAACM,WAAlC,EAA+C;AAC7CF,IAAAA,IAAI,CAACC,SAAL,GAAiBL,IAAI,CAACM,WAAtB;AACD;;AAEDN,EAAAA,IAAI,CAACG,OAAL,CAAaI,IAAb,CAAkB,IAAlB,EAAwBH,IAAxB,EATqB,CAWrB;;AACA,OAAKI,OAAL,GAAe,KAAKA,OAAL,KAAiBC,SAAjB,GAA6B,KAAKC,UAAlC,GAA+C,KAAKF,OAAnE;AACA,OAAKG,OAAL,GAAe,KAAKA,OAAL,IAAgB,KAAKC,UAApC;;AAEA,MAAIR,IAAI,IAAIA,IAAI,CAACS,SAAL,IAAkB,IAA9B,EAAoC;AAClC,SAAKC,UAAL,GAAkBV,IAAI,CAACS,SAAvB;AACD;AACF;;AAED,SAASE,aAAT,CAAuBX,IAAvB,EAA6B;AAC3B,SAAO,IAAID,OAAJ,CAAYC,IAAZ,CAAP;AACD;;AAED,SAASY,MAAT,CAAgBC,MAAhB,EAAwBC,QAAxB,EAAkC;AAChC,MAAIA,QAAJ,EAAc;AACZC,IAAAA,OAAO,CAACC,QAAR,CAAiBF,QAAjB;AACD,GAH+B,CAKhC;;;AACA,MAAI,CAACD,MAAM,CAACI,OAAZ,EAAqB;AACnB;AACD;;AAEDJ,EAAAA,MAAM,CAACI,OAAP,CAAeC,KAAf;;AACAL,EAAAA,MAAM,CAACI,OAAP,GAAiB,IAAjB;AACD;;AAEDlB,OAAO,CAACoB,SAAR,CAAkBC,aAAlB,GAAkC,UAAUC,KAAV,EAAiBC,SAAjB,EAA4BC,OAA5B,EAAqC;AACrE,MAAI,OAAOA,OAAP,KAAmB,UAAvB,EAAmC;AACjC,WAAO3B,IAAI,CAACG,OAAL,CAAaqB,aAAb,CAA2BjB,IAA3B,CAAgC,IAAhC,EAAsCkB,KAAtC,EAA6CC,SAA7C,EAAwDC,OAAxD,CAAP;AACD;;AAED,MAAIC,IAAI,GAAG,IAAX;AAEA,MAAIC,aAAa,GAAGJ,KAAK,IAAIA,KAAK,CAACK,MAAnC;AACA,MAAIC,cAAc,GAAG,KAAKC,UAAL,GAAkB,KAAKxB,OAA5C;AACA,MAAIyB,aAAa,GAAG,KAAKnB,UAAzB;AACA,MAAIoB,KAAK,GAAG,CAAZ;AAEA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,KAAK,GAAG,CAAZ;AAEA,MAAIC,KAAJ;AACA,OAAKC,EAAL,CAAQ,OAAR,EAAiB,UAAUC,GAAV,EAAe;AAC9BF,IAAAA,KAAK,GAAGE,GAAR;AACD,GAFD;;AAIA,WAASC,WAAT,CAAqBC,YAArB,EAAmCC,aAAnC,EAAkD;AAChD,QAAId,IAAI,CAACe,SAAT,EAAoB;AAClB;AACD;;AAED,QAAIC,IAAI,GAAGb,cAAc,GAAGW,aAA5B;AACA7C,IAAAA,MAAM,CAAC+C,IAAI,IAAI,CAAT,EAAY,yBAAZ,CAAN;;AAEA,QAAIA,IAAI,GAAG,CAAX,EAAc;AACZ,UAAIC,GAAG,GAAGjB,IAAI,CAACjB,OAAL,CAAamC,KAAb,CAAmBlB,IAAI,CAACpB,OAAxB,EAAiCoB,IAAI,CAACpB,OAAL,GAAeoC,IAAhD,CAAV;;AACAhB,MAAAA,IAAI,CAACpB,OAAL,IAAgBoC,IAAhB;;AAEA,UAAIC,GAAG,CAACf,MAAJ,GAAaG,aAAjB,EAAgC;AAC9BY,QAAAA,GAAG,GAAGA,GAAG,CAACC,KAAJ,CAAU,CAAV,EAAab,aAAb,CAAN;AACD;;AAEDE,MAAAA,OAAO,CAACY,IAAR,CAAaF,GAAb;AACAT,MAAAA,KAAK,IAAIS,GAAG,CAACf,MAAb;AACAG,MAAAA,aAAa,IAAIY,GAAG,CAACf,MAArB;;AAEA,UAAIG,aAAa,KAAK,CAAtB,EAAyB;AACvB,eAAO,KAAP;AACD;AACF;;AAED,QAAIS,aAAa,KAAK,CAAlB,IAAuBd,IAAI,CAACpB,OAAL,IAAgBoB,IAAI,CAACI,UAAhD,EAA4D;AAC1DD,MAAAA,cAAc,GAAGH,IAAI,CAACI,UAAtB;AACAJ,MAAAA,IAAI,CAACpB,OAAL,GAAe,CAAf;AACAoB,MAAAA,IAAI,CAACjB,OAAL,GAAeqC,MAAM,CAACC,WAAP,CAAmBrB,IAAI,CAACI,UAAxB,CAAf;AACD;;AAED,QAAIU,aAAa,KAAK,CAAtB,EAAyB;AACvBR,MAAAA,KAAK,IAAIL,aAAa,GAAGY,YAAzB;AACAZ,MAAAA,aAAa,GAAGY,YAAhB;AAEA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AAED5C,EAAAA,MAAM,CAAC,KAAKwB,OAAN,EAAe,qBAAf,CAAN;AACA,MAAI6B,GAAJ;;AACA,KAAG;AACDA,IAAAA,GAAG,GAAG,KAAK7B,OAAL,CAAa8B,SAAb,CACJzB,SADI,EAEJD,KAFI,EAEG;AACPS,IAAAA,KAHI,EAGG;AACPL,IAAAA,aAJI,EAIW;AACf,SAAKlB,OALD,EAKU;AACd,SAAKH,OAND,EAMU;AACduB,IAAAA,cAPI,CAAN,CADC,CASE;AACH;;AACAmB,IAAAA,GAAG,GAAGA,GAAG,IAAI,KAAKE,WAAlB;AACD,GAZD,QAYS,CAAC,KAAKT,SAAN,IAAmBH,WAAW,CAACU,GAAG,CAAC,CAAD,CAAJ,EAASA,GAAG,CAAC,CAAD,CAAZ,CAZvC;;AAcA,MAAI,KAAKP,SAAT,EAAoB;AAClB,UAAMN,KAAN;AACD;;AAED,MAAID,KAAK,IAAIlC,UAAb,EAAyB;AACvBc,IAAAA,MAAM,CAAC,IAAD,CAAN;;AACA,UAAM,IAAIqC,UAAJ,CACJ,2DACEnD,UAAU,CAACoD,QAAX,CAAoB,EAApB,CADF,GAEE,QAHE,CAAN;AAKD;;AAED,MAAIC,GAAG,GAAGP,MAAM,CAACQ,MAAP,CAAcrB,OAAd,EAAuBC,KAAvB,CAAV;;AACApB,EAAAA,MAAM,CAAC,IAAD,CAAN;;AAEA,SAAOuC,GAAP;AACD,CA9FD;;AAgGAtD,IAAI,CAACwD,QAAL,CAActD,OAAd,EAAuBH,IAAI,CAACG,OAA5B;;AAEA,SAASuD,cAAT,CAAwBzC,MAAxB,EAAgC0C,MAAhC,EAAwC;AACtC,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9BA,IAAAA,MAAM,GAAGX,MAAM,CAACY,IAAP,CAAYD,MAAZ,CAAT;AACD;;AACD,MAAI,EAAEA,MAAM,YAAYX,MAApB,CAAJ,EAAiC;AAC/B,UAAM,IAAIa,SAAJ,CAAc,wBAAd,CAAN;AACD;;AAED,MAAInC,SAAS,GAAGT,MAAM,CAAC6C,gBAAvB;;AACA,MAAIpC,SAAS,IAAI,IAAjB,EAAuB;AACrBA,IAAAA,SAAS,GAAG1B,IAAI,CAAC+D,QAAjB;AACD;;AAED,SAAO9C,MAAM,CAACO,aAAP,CAAqBmC,MAArB,EAA6BjC,SAA7B,CAAP;AACD;;AAED,SAASsC,WAAT,CAAqBL,MAArB,EAA6BvD,IAA7B,EAAmC;AACjC,SAAOsD,cAAc,CAAC,IAAIvD,OAAJ,CAAYC,IAAZ,CAAD,EAAoBuD,MAApB,CAArB;AACD;;AAEDM,MAAM,CAACC,OAAP,GAAiBA,OAAO,GAAGF,WAA3B;AACAE,OAAO,CAAC/D,OAAR,GAAkBA,OAAlB;AACA+D,OAAO,CAACnD,aAAR,GAAwBA,aAAxB;AACAmD,OAAO,CAACF,WAAR,GAAsBA,WAAtB","sourcesContent":["\"use strict\";\n\nlet assert = require(\"assert\").ok;\nlet zlib = require(\"zlib\");\nlet util = require(\"util\");\n\nlet kMaxLength = require(\"buffer\").kMaxLength;\n\nfunction Inflate(opts) {\n  if (!(this instanceof Inflate)) {\n    return new Inflate(opts);\n  }\n\n  if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {\n    opts.chunkSize = zlib.Z_MIN_CHUNK;\n  }\n\n  zlib.Inflate.call(this, opts);\n\n  // Node 8 --> 9 compatibility check\n  this._offset = this._offset === undefined ? this._outOffset : this._offset;\n  this._buffer = this._buffer || this._outBuffer;\n\n  if (opts && opts.maxLength != null) {\n    this._maxLength = opts.maxLength;\n  }\n}\n\nfunction createInflate(opts) {\n  return new Inflate(opts);\n}\n\nfunction _close(engine, callback) {\n  if (callback) {\n    process.nextTick(callback);\n  }\n\n  // Caller may invoke .close after a zlib error (which will null _handle).\n  if (!engine._handle) {\n    return;\n  }\n\n  engine._handle.close();\n  engine._handle = null;\n}\n\nInflate.prototype._processChunk = function (chunk, flushFlag, asyncCb) {\n  if (typeof asyncCb === \"function\") {\n    return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);\n  }\n\n  let self = this;\n\n  let availInBefore = chunk && chunk.length;\n  let availOutBefore = this._chunkSize - this._offset;\n  let leftToInflate = this._maxLength;\n  let inOff = 0;\n\n  let buffers = [];\n  let nread = 0;\n\n  let error;\n  this.on(\"error\", function (err) {\n    error = err;\n  });\n\n  function handleChunk(availInAfter, availOutAfter) {\n    if (self._hadError) {\n      return;\n    }\n\n    let have = availOutBefore - availOutAfter;\n    assert(have >= 0, \"have should not go down\");\n\n    if (have > 0) {\n      let out = self._buffer.slice(self._offset, self._offset + have);\n      self._offset += have;\n\n      if (out.length > leftToInflate) {\n        out = out.slice(0, leftToInflate);\n      }\n\n      buffers.push(out);\n      nread += out.length;\n      leftToInflate -= out.length;\n\n      if (leftToInflate === 0) {\n        return false;\n      }\n    }\n\n    if (availOutAfter === 0 || self._offset >= self._chunkSize) {\n      availOutBefore = self._chunkSize;\n      self._offset = 0;\n      self._buffer = Buffer.allocUnsafe(self._chunkSize);\n    }\n\n    if (availOutAfter === 0) {\n      inOff += availInBefore - availInAfter;\n      availInBefore = availInAfter;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  assert(this._handle, \"zlib binding closed\");\n  let res;\n  do {\n    res = this._handle.writeSync(\n      flushFlag,\n      chunk, // in\n      inOff, // in_off\n      availInBefore, // in_len\n      this._buffer, // out\n      this._offset, //out_off\n      availOutBefore\n    ); // out_len\n    // Node 8 --> 9 compatibility check\n    res = res || this._writeState;\n  } while (!this._hadError && handleChunk(res[0], res[1]));\n\n  if (this._hadError) {\n    throw error;\n  }\n\n  if (nread >= kMaxLength) {\n    _close(this);\n    throw new RangeError(\n      \"Cannot create final Buffer. It would be larger than 0x\" +\n        kMaxLength.toString(16) +\n        \" bytes\"\n    );\n  }\n\n  let buf = Buffer.concat(buffers, nread);\n  _close(this);\n\n  return buf;\n};\n\nutil.inherits(Inflate, zlib.Inflate);\n\nfunction zlibBufferSync(engine, buffer) {\n  if (typeof buffer === \"string\") {\n    buffer = Buffer.from(buffer);\n  }\n  if (!(buffer instanceof Buffer)) {\n    throw new TypeError(\"Not a string or buffer\");\n  }\n\n  let flushFlag = engine._finishFlushFlag;\n  if (flushFlag == null) {\n    flushFlag = zlib.Z_FINISH;\n  }\n\n  return engine._processChunk(buffer, flushFlag);\n}\n\nfunction inflateSync(buffer, opts) {\n  return zlibBufferSync(new Inflate(opts), buffer);\n}\n\nmodule.exports = exports = inflateSync;\nexports.Inflate = Inflate;\nexports.createInflate = createInflate;\nexports.inflateSync = inflateSync;\n"]},"metadata":{},"sourceType":"script"}