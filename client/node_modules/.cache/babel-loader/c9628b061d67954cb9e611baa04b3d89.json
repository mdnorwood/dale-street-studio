{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar libpath = process.env.TEST_COV ? '../lib-cov/' : '../lib/';\n\nvar detector = require(libpath + 'detector');\n\nvar handlers = {};\n\nvar types = require(libpath + 'types'); // load all available handlers\n\n\ntypes.forEach(function (type) {\n  handlers[type] = require(libpath + 'types/' + type);\n}); // Maximum buffer size, with a default of 128 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\n\nvar MaxBufferSize = 128 * 1024;\n\nfunction lookup(buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  var type = detector(buffer, filepath); // find an appropriate handler for this file type\n\n  if (type in handlers) {\n    var size = handlers[type].calculate(buffer, filepath);\n\n    if (size !== false) {\n      size.type = type;\n      return size;\n    }\n  } // throw up, if we don't understand the file\n\n\n  throw new TypeError('unsupported file type');\n}\n\nfunction asyncFileToBuffer(filepath, callback) {\n  // open the file in read only mode\n  fs.open(filepath, 'r', function (err, descriptor) {\n    if (err) {\n      return callback(err);\n    }\n\n    var size = fs.fstatSync(descriptor).size;\n    var bufferSize = Math.min(size, MaxBufferSize);\n    var buffer = new Buffer(bufferSize); // read first buffer block from the file, asynchronously\n\n    fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {\n      if (err) {\n        return callback(err);\n      } // close the file, we are done\n\n\n      fs.close(descriptor, function (err) {\n        callback(err, buffer);\n      });\n    });\n  });\n}\n\nfunction syncFileToBuffer(filepath) {\n  // read from the file, synchronously\n  var descriptor = fs.openSync(filepath, 'r');\n  var size = fs.fstatSync(descriptor).size;\n  var bufferSize = Math.min(size, MaxBufferSize);\n  var buffer = new Buffer(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n}\n/**\n * @params input - buffer or relative/absolute path of the image file\n * @params callback - optional function for async detection\n */\n\n\nmodule.exports = function (input, callback) {\n  // Handle buffer input\n  if (input instanceof Buffer) {\n    return lookup(input);\n  } // input should be a string at this point\n\n\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  } // resolve the file path\n\n\n  var filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    asyncFileToBuffer(filepath, function (err, buffer) {\n      if (err) {\n        return callback(err);\n      } // return the dimensions\n\n\n      var dimensions;\n\n      try {\n        dimensions = lookup(buffer, filepath);\n      } catch (e) {\n        err = e;\n      }\n\n      callback(err, dimensions);\n    });\n  } else {\n    var buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/image-size/lib/index.js"],"names":["fs","require","path","libpath","process","env","TEST_COV","detector","handlers","types","forEach","type","MaxBufferSize","lookup","buffer","filepath","size","calculate","TypeError","asyncFileToBuffer","callback","open","err","descriptor","fstatSync","bufferSize","Math","min","Buffer","read","close","syncFileToBuffer","openSync","readSync","closeSync","module","exports","input","resolve","dimensions","e"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\n\nvar libpath = process.env.TEST_COV ? '../lib-cov/' : '../lib/';\nvar detector = require(libpath + 'detector');\n\nvar handlers = {};\nvar types = require(libpath + 'types');\n\n// load all available handlers\ntypes.forEach(function (type) {\n  handlers[type] = require(libpath + 'types/' + type);\n});\n\n// Maximum buffer size, with a default of 128 kilobytes.\n// TO-DO: make this adaptive based on the initial signature of the image\nvar MaxBufferSize = 128*1024;\n\nfunction lookup (buffer, filepath) {\n  // detect the file type.. don't rely on the extension\n  var type = detector(buffer, filepath);\n\n  // find an appropriate handler for this file type\n  if (type in handlers) {\n    var size = handlers[type].calculate(buffer, filepath);\n    if (size !== false) {\n      size.type = type;\n      return size;\n    }\n  }\n\n  // throw up, if we don't understand the file\n  throw new TypeError('unsupported file type');\n}\n\nfunction asyncFileToBuffer (filepath, callback) {\n  // open the file in read only mode\n  fs.open(filepath, 'r', function (err, descriptor) {\n    if (err) { return callback(err); }\n    var size = fs.fstatSync(descriptor).size;\n    var bufferSize = Math.min(size, MaxBufferSize);\n    var buffer = new Buffer(bufferSize);\n    // read first buffer block from the file, asynchronously\n    fs.read(descriptor, buffer, 0, bufferSize, 0, function (err) {\n      if (err) { return callback(err); }\n      // close the file, we are done\n      fs.close(descriptor, function (err) {\n        callback(err, buffer);\n      });\n    });\n  });\n}\n\nfunction syncFileToBuffer (filepath) {\n  // read from the file, synchronously\n  var descriptor = fs.openSync(filepath, 'r');\n  var size = fs.fstatSync(descriptor).size;\n  var bufferSize = Math.min(size, MaxBufferSize);\n  var buffer = new Buffer(bufferSize);\n  fs.readSync(descriptor, buffer, 0, bufferSize, 0);\n  fs.closeSync(descriptor);\n  return buffer;\n}\n\n/**\n * @params input - buffer or relative/absolute path of the image file\n * @params callback - optional function for async detection\n */\nmodule.exports = function (input, callback) {\n\n  // Handle buffer input\n  if (input instanceof Buffer) {\n    return lookup(input);\n  }\n\n  // input should be a string at this point\n  if (typeof input !== 'string') {\n    throw new TypeError('invalid invocation');\n  }\n\n  // resolve the file path\n  var filepath = path.resolve(input);\n\n  if (typeof callback === 'function') {\n    asyncFileToBuffer(filepath, function (err, buffer) {\n      if (err) { return callback(err); }\n\n      // return the dimensions\n      var dimensions;\n      try {\n        dimensions = lookup(buffer, filepath);\n      } catch (e) {\n        err = e;\n      }\n      callback(err, dimensions);\n    });\n  } else {\n    var buffer = syncFileToBuffer(filepath);\n    return lookup(buffer, filepath);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}