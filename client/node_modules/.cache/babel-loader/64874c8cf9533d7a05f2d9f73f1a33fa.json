{"ast":null,"code":"var path = require('path');\n\nvar concat = require('concat-stream');\n\nvar ndarray = require('ndarray');\n\nvar savePixels = require('save-pixels');\n\nvar exporters = {}; // Function to add new exporters\n\nfunction addExporter(name, exporter) {\n  exporters[name] = exporter;\n} // Helper to create exporters (could be a class for better abstraction)\n\n\nfunction getPngExporter(ext) {\n  /**\n   * Generic exporter\n   * @param {Object} options Options to export with\n   * @param {Number} [options.quality] Quality of the exported item\n   * @param {Function} cb Error-first callback to return binary image string to\n   */\n  return function pngExporterFn(options, cb) {\n    var that = this; // Add the image to the data itself (easier via offsets)\n\n    var data = this.data;\n    var images = this.images;\n    images.forEach(function getUrlPath(imageObj) {\n      // Iterate over the image's data across its rows\n      // setting the original data at that offset\n      // [1, 2, 0, 0,\n      //  3, 4, 0, 0,\n      //  0, 0, 5, 0,\n      //  0, 0, 0, 6]\n      // Set [1, 2] at 0 + 0 * canvasRow.length (x offset + ((y + imageRow index) * canvasRow length))\n      // Set [3, 4] at 0 + 1 * canvasRow.length (x offset + ((y + imageRow index) * canvasRow length))\n      var img = imageObj.img;\n      var imageXOffset = imageObj.x * 4;\n      var canvasRowWidth = that.width * 4;\n      var imageRowWidth = img.width * 4;\n      var imgData = img.data;\n      var imageYOffset = imageObj.y;\n      var imageRowIndex = 0;\n      var imageRowCount = img.height;\n\n      for (; imageRowIndex < imageRowCount; imageRowIndex += 1) {\n        // TODO: Use ndarray operations\n        // TODO: or move to separate node module\n        // TODO: It would be more space efficient to iterate over the indices and set each one\n        var subarray = imgData.subarray(imageRowIndex * imageRowWidth, (imageRowIndex + 1) * imageRowWidth);\n        var offset = imageXOffset + (imageYOffset + imageRowIndex) * canvasRowWidth;\n        data.set(subarray, offset);\n      }\n    }); // Concatenate the ndarray into a png\n    // TODO: We should start sending back streams\n\n    savePixels(this.ndarray, 'png').pipe(concat(function concatenateImage(buff) {\n      cb(null, buff.toString('binary'));\n    }));\n  };\n} // Generate the png exporter\n\n\nvar pngExporter = getPngExporter('png');\naddExporter('png', pngExporter);\naddExporter('image/png', pngExporter); // Export our exporters\n\nmodule.exports = {\n  exporters: exporters,\n  addExporter: addExporter\n};","map":{"version":3,"sources":["/Users/marcusnorwood/Sites/music-site/dale-street-studio-music/client/node_modules/pngsmith/lib/exporters.js"],"names":["path","require","concat","ndarray","savePixels","exporters","addExporter","name","exporter","getPngExporter","ext","pngExporterFn","options","cb","that","data","images","forEach","getUrlPath","imageObj","img","imageXOffset","x","canvasRowWidth","width","imageRowWidth","imgData","imageYOffset","y","imageRowIndex","imageRowCount","height","subarray","offset","set","pipe","concatenateImage","buff","toString","pngExporter","module","exports"],"mappings":"AAAA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIG,UAAU,GAAGH,OAAO,CAAC,aAAD,CAAxB;;AACA,IAAII,SAAS,GAAG,EAAhB,C,CAEA;;AACA,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,QAA3B,EAAqC;AACnCH,EAAAA,SAAS,CAACE,IAAD,CAAT,GAAkBC,QAAlB;AACD,C,CAED;;;AACA,SAASC,cAAT,CAAwBC,GAAxB,EAA6B;AAC3B;AACF;AACA;AACA;AACA;AACA;AACE,SAAO,SAASC,aAAT,CAAwBC,OAAxB,EAAiCC,EAAjC,EAAqC;AAC1C,QAAIC,IAAI,GAAG,IAAX,CAD0C,CAG1C;;AACA,QAAIC,IAAI,GAAG,KAAKA,IAAhB;AACA,QAAIC,MAAM,GAAG,KAAKA,MAAlB;AACAA,IAAAA,MAAM,CAACC,OAAP,CAAe,SAASC,UAAT,CAAqBC,QAArB,EAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAIC,GAAG,GAAGD,QAAQ,CAACC,GAAnB;AACA,UAAIC,YAAY,GAAGF,QAAQ,CAACG,CAAT,GAAa,CAAhC;AACA,UAAIC,cAAc,GAAGT,IAAI,CAACU,KAAL,GAAa,CAAlC;AACA,UAAIC,aAAa,GAAGL,GAAG,CAACI,KAAJ,GAAY,CAAhC;AACA,UAAIE,OAAO,GAAGN,GAAG,CAACL,IAAlB;AACA,UAAIY,YAAY,GAAGR,QAAQ,CAACS,CAA5B;AACA,UAAIC,aAAa,GAAG,CAApB;AACA,UAAIC,aAAa,GAAGV,GAAG,CAACW,MAAxB;;AACA,aAAOF,aAAa,GAAGC,aAAvB,EAAsCD,aAAa,IAAI,CAAvD,EAA0D;AACxD;AACA;AACA;AACA,YAAIG,QAAQ,GAAGN,OAAO,CAACM,QAAR,CAAiBH,aAAa,GAAGJ,aAAjC,EAAgD,CAACI,aAAa,GAAG,CAAjB,IAAsBJ,aAAtE,CAAf;AACA,YAAIQ,MAAM,GAAGZ,YAAY,GAAI,CAACM,YAAY,GAAGE,aAAhB,IAAiCN,cAA9D;AACAR,QAAAA,IAAI,CAACmB,GAAL,CAASF,QAAT,EAAmBC,MAAnB;AACD;AACF,KAzBD,EAN0C,CAiC1C;AACA;;AACA7B,IAAAA,UAAU,CAAC,KAAKD,OAAN,EAAe,KAAf,CAAV,CAAgCgC,IAAhC,CAAqCjC,MAAM,CAAC,SAASkC,gBAAT,CAA2BC,IAA3B,EAAiC;AAC3ExB,MAAAA,EAAE,CAAC,IAAD,EAAOwB,IAAI,CAACC,QAAL,CAAc,QAAd,CAAP,CAAF;AACD,KAF0C,CAA3C;AAGD,GAtCD;AAuCD,C,CAED;;;AACA,IAAIC,WAAW,GAAG9B,cAAc,CAAC,KAAD,CAAhC;AACAH,WAAW,CAAC,KAAD,EAAQiC,WAAR,CAAX;AACAjC,WAAW,CAAC,WAAD,EAAciC,WAAd,CAAX,C,CAEA;;AACAC,MAAM,CAACC,OAAP,GAAiB;AACfpC,EAAAA,SAAS,EAAEA,SADI;AAEfC,EAAAA,WAAW,EAAEA;AAFE,CAAjB","sourcesContent":["var path = require('path');\nvar concat = require('concat-stream');\nvar ndarray = require('ndarray');\nvar savePixels = require('save-pixels');\nvar exporters = {};\n\n// Function to add new exporters\nfunction addExporter(name, exporter) {\n  exporters[name] = exporter;\n}\n\n// Helper to create exporters (could be a class for better abstraction)\nfunction getPngExporter(ext) {\n  /**\n   * Generic exporter\n   * @param {Object} options Options to export with\n   * @param {Number} [options.quality] Quality of the exported item\n   * @param {Function} cb Error-first callback to return binary image string to\n   */\n  return function pngExporterFn (options, cb) {\n    var that = this;\n\n    // Add the image to the data itself (easier via offsets)\n    var data = this.data;\n    var images = this.images;\n    images.forEach(function getUrlPath (imageObj) {\n      // Iterate over the image's data across its rows\n      // setting the original data at that offset\n      // [1, 2, 0, 0,\n      //  3, 4, 0, 0,\n      //  0, 0, 5, 0,\n      //  0, 0, 0, 6]\n      // Set [1, 2] at 0 + 0 * canvasRow.length (x offset + ((y + imageRow index) * canvasRow length))\n      // Set [3, 4] at 0 + 1 * canvasRow.length (x offset + ((y + imageRow index) * canvasRow length))\n      var img = imageObj.img;\n      var imageXOffset = imageObj.x * 4;\n      var canvasRowWidth = that.width * 4;\n      var imageRowWidth = img.width * 4;\n      var imgData = img.data;\n      var imageYOffset = imageObj.y;\n      var imageRowIndex = 0;\n      var imageRowCount = img.height;\n      for (; imageRowIndex < imageRowCount; imageRowIndex += 1) {\n        // TODO: Use ndarray operations\n        // TODO: or move to separate node module\n        // TODO: It would be more space efficient to iterate over the indices and set each one\n        var subarray = imgData.subarray(imageRowIndex * imageRowWidth, (imageRowIndex + 1) * imageRowWidth);\n        var offset = imageXOffset + ((imageYOffset + imageRowIndex) * canvasRowWidth);\n        data.set(subarray, offset);\n      }\n    });\n\n    // Concatenate the ndarray into a png\n    // TODO: We should start sending back streams\n    savePixels(this.ndarray, 'png').pipe(concat(function concatenateImage (buff) {\n      cb(null, buff.toString('binary'));\n    }));\n  };\n}\n\n// Generate the png exporter\nvar pngExporter = getPngExporter('png');\naddExporter('png', pngExporter);\naddExporter('image/png', pngExporter);\n\n// Export our exporters\nmodule.exports = {\n  exporters: exporters,\n  addExporter: addExporter\n};"]},"metadata":{},"sourceType":"script"}